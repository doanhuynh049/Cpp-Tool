<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SmartSockets::TipcMon class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.12 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>SmartSockets::TipcMon  Class Reference</h1><code>#include &lt;<a class="el" href="tmon_8h-source.html">tmon.h</a>&gt;</code>
<p>
<a href="classSmartSockets_1_1TipcMon-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a0">TipcMon</a> (const <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a> &amp;tsrv)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a1">~TipcMon</a> ()  throw ()</td></tr>
<tr><td nowrap align=right valign=top>const char *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a2">getIdentStr</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a3">setIdentStr</a> (const char *type_str)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top><a name="a4" doxytag="SmartSockets::TipcMon::printWatch"></a>
void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a4">printWatch</a> (T_OUT_FUNC out_func=(T_OUT_FUNC) TutOut)  throw (TipcException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Print all monitoring categories being watched.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a5">projectNamesGetWatch</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a6">projectNamesSetWatch</a> (bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a7">clientNamesGetWatch</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a8">clientNamesSetWatch</a> (bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a9">serverNamesGetWatch</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a10">serverNamesSetWatch</a> (bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top><a name="a11" doxytag="SmartSockets::TipcMon::subjectNamesGetWatch"></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a11">subjectNamesGetWatch</a> () const  throw (TipcException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Determines whether RTclient is watching subject names.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a12">subjectNamesSetWatch</a> (bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a13">subjectSubscribeGetWatch</a> (const char *subject_name) const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a14">subjectSubscribeSetWatch</a> (const char *subject_name, bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a15">projectNamesPoll</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a16">subjectNamesPoll</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a17">subjectSubscribePoll</a> (const char *dg_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a18">clientNamesPoll</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a19">serverNamesPoll</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a20">serverConnGetWatch</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a21">serverConnSetWatch</a> (bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a22">serverConnPoll</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a23">serverGeneralPoll</a> (const char *serverName)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a24">serverTimePoll</a> (const char *serverName)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a25">serverBufferPoll</a> (const char *serverName, const char *connected_process_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a26">serverOptionPoll</a> (const char *serverName, const char *option_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a27">serverMsgTrafficPoll</a> (const char *serverName, const char *connected_process_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a28">serverMsgTrafficExPoll</a> (const char *serverName, const char *connected_process_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a29">serverRoutePoll</a> (const char *serverName, const char *dest_server_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top><a name="a30" doxytag="SmartSockets::TipcMon::clientSubscribeGetWatch"></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a30">clientSubscribeGetWatch</a> (const char *clientName) const  throw (TipcException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Determines whether this RTclient is watching the subjects that an RTclient is subscribing to.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a31">clientSubscribeSetWatch</a> (const char *clientName, bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top><a name="a32" doxytag="SmartSockets::TipcMon::clientTimeGetWatch"></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a32">clientTimeGetWatch</a> (const char *clientName) const  throw (TipcException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Determines whether this RTclient is watching time information for an RTclient.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a33">clientTimeSetWatch</a> (const char *clientName, bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top><a name="a34" doxytag="SmartSockets::TipcMon::clientBufferGetWatch"></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a34">clientBufferGetWatch</a> (const char *clientName) const  throw (TipcException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Determines whether this RTclient is watching message-related buffer information in an RTclient.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a35">clientBufferSetWatch</a> (const char *clientName, bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top><a name="a36" doxytag="SmartSockets::TipcMon::clientMsgRecvGetWatch"></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a36">clientMsgRecvGetWatch</a> (const char *clientName, const char *msg_type_name) const  throw (TipcException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Determines whether this RTclient is watching received messages in an RTclient.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a37">clientMsgRecvSetWatch</a> (const char *clientName, const char *msg_type_name, bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top><a name="a38" doxytag="SmartSockets::TipcMon::clientMsgSendGetWatch"></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a38">clientMsgSendGetWatch</a> (const char *clientName, const char *msg_type_name) const  throw (TipcException)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Determines whether this RTclient is watching sent messages in an RTclient.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a39">clientMsgSendSetWatch</a> (const char *clientName, const char *msg_type_name, bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a40">clientSubscribePoll</a> (const char *clientName)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a41">clientGeneralPoll</a> (const char *clientName)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a42">clientTimePoll</a> (const char *clientName)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a43">clientBufferPoll</a> (const char *clientName)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a44">clientOptionPoll</a> (const char *clientName, const char *option_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a45">clientMsgTypePoll</a> (const char *clientName, const char *msg_type_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a46">clientMsgTypeExPoll</a> (const char *clientName, const char *msg_type_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a47">clientCbPoll</a> (const char *clientName)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a48">clientMsgTrafficPoll</a> (const char *clientName)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a49">clientSubjectPoll</a> (const char *clientName, const char *subject_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a50">clientSubjectExPoll</a> (const char *clientName, const char *subject_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a51">clientNamesNumPoll</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a52">clientSubscribeNumPoll</a> (const char *client_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a53">clientCpuPoll</a> (const char *client_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a54">serverCpuPoll</a> (const char *server_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a55">clientInfoPoll</a> (const char *client_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a56">clientCongestionSetWatch</a> (const char *client_name, int4 high_water, int4 low_water, bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a57">serverCongestionSetWatch</a> (const char *server_name, const char *connected_process_name, int4 high_water, int4 low_water, bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a58">serverMaxClientLicensesSetWatch</a> (const char *server_name, bool watch_status)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a59">clientCongestionGetWatch</a> (const char *client_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a60">serverCongestionGetWatch</a> (const char *server_name, const char *connected_process_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a61">serverMaxClientLicensesGetWatch</a> (const char *server_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a62">clientExtPoll</a> (const char *client_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a63">serverStartTimePoll</a> (const char *serverName)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a64">serverVersionPoll</a> (const char *server_name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcMon.html#a65">clientVersionPoll</a> (const char *client_name)  throw (TipcException)</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Enables users to send monitoring requests to a specified RTserver connection. RTclient processes have monitoring capabilities to gather information about your project, as well as determining where processes are located in your network.
<p>
From within an RTclient, hundreds of pieces of information can be gathered in real time about all parts of a running SmartSockets project. These are some of the kinds of information available:<ul>
<li>Information about RTclients:<br>
<ul>
<li>names<br>
<li>message buffers<br>
<li>message traffic statistics<br>
<li>message types<br>
<li>options<br>
<li>CPU usage<br>
<li>memory usage<br>
<li>node the RTClient is on<br>
<li>options<br>
<li>current time<br>
<li>subjects the RTClient is subscribed to<br>
</ul>
<li>Information about RTservers:<br>
<ul>
<li>names <br>
<li>message buffers <br>
<li>message traffic statistics <br>
<li>connections <br>
<li>options <br>
<li>CPU usage <br>
<li>memory usage <br>
<li>node the RTServer is on <br>
<li>options <br>
<li>current time <br>
</ul>
<li>Information about Subjects: <br>
<ul>
<li>names <br>
<li>RTclients that are subscribing <br>
</ul>
<li>Information about Projects: <br>
<ul>
<li>names <br>
</ul>
</ul>
This information can be either polled once to provide a one-time snapshot of information or watched to provide asynchronous updates when changes occur. A monitoring request can specify either a specific object or all objects matching a wildcard scope filter. The information is delivered to the requesting program in standard message types, prefixed with T_MT_MON_. (For brevity, the T_MT_ portion is omitted from this point on.) The fields of these monitoring message types contain the information the RTclient is interested in. In other words, this class does not parse the results of the monitoring requests; it simply builds the requests and sends them to the RTserver. It's up to the application to write a callback that receives a monitoring reply message and parses out the desired information.
<p>
There is no monitoring available for peer-to-peer connections or for programs that do not use the SmartSockets API or C++ Class Library.
<p>
Monitoring is built into SmartSockets. No user-defined code is needed to support monitoring in an RTclient. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="SmartSockets::TipcMon::TipcMon"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SmartSockets::TipcMon::TipcMon </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>tsrv</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>tsrv</em>&nbsp;</td><td>
server connection used to send the monitoring request. All resuls received from the monitoring requests should be trapped using this object (either by calling <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or by creating a callback on the appropriate message type. </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 thrown if the connection to RTserver is invalid. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a1" doxytag="SmartSockets::TipcMon::~TipcMon"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual SmartSockets::TipcMon::~TipcMon </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw ()<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a43" doxytag="SmartSockets::TipcMon::clientBufferPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientBufferPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>clientName</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTclient message-related buffer information by sending a MON_CLIENT_BUFFER_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. The polled RTclient responds by sending back a MON_CLIENT_BUFFER_POLL_RESULT message. The response may or may not come back quickly, depending on what the polled RTclient is doing. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a>:: mainLoop() to get the response. Each MON_CLIENT_BUFFER_POLL_RESULT message contains five fields:<ul>
<li>a STR field containing the name of the RTclient<li>an INT4 field containing the number of queued incoming message in the RTclient's connection to RTserver<li>an INT4 field containing the number of bytes of data in the queued incoming messages in the RTclient's connection to RTserver<li>an INT4 field containing the number of bytes of data in the read buffer in the RTclient's connection to RTserver<li>an INT4 field containing the number of bytes of data in the write buffer in the RTclient's connection to RTserver There are multiple responses only if client_name is a wildcard or T_IPC_MON_ALL. To watch RTclient buffer information, use clientBufferSetWatch. </ul>
    </td>
  </tr>
</table>
<a name="a35" doxytag="SmartSockets::TipcMon::clientBufferSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientBufferSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>clientName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>watch_status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets whether or not this RTclient is watching message-related buffer information in the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to watch all RTclients in the project that match the value of the Monitor_Scope option. clientBufferSetWatch saves the watch status and sends a MON_CLIENT_BUFFER_SET_WATCH message to the client_name RTclient. The watch status controls whether or not the RTclient receives a MON_CLIENT_BUFFER_STATUS message each time the message queue for the connection to RTserver changes in the watched RTclient. The watch status is saved internally so that the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver. Each MON_CLIENT_BUFFER_STATUS message contains five fields:<ul>
<li>a STR field containing the name of the RTclient<li>an INT4 field containing the number of queued incoming message in the RTclient's connection to RTserver<li>an INT4 field containing the number of bytes of data in the queued incoming messages in the RTclient's connection to RTserver<li>an INT4 field containing the number of bytes of data in the read buffer in the RTclient's connection to RTserver<li>an INT4 field containing the number of bytes of data in the write buffer in the RTclient's connection to RTserver In addition to sending a MON_CLIENT_BUFFER_STATUS message each time the message queue changes, the watched RTclient also sends an initial MON_CLIENT_BUFFER_STATUS message when the watch status is set to TRUE, so that the RTclient does not have to wait for the next message queue change to receive the first MON_CLIENT_BUFFER_STATUS message. To determine if this RTclient is watching RTclient buffer information, use clientBufferGetWatch. To poll once for RTclient buffer information, use clientBufferPoll. For an example of how MON_CLIENT_BUFFER_STATUS messages can be used, see the RTmon GDI Watch Client Buffer window. </ul>
    </td>
  </tr>
</table>
<a name="a47" doxytag="SmartSockets::TipcMon::clientCbPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientCbPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>clientName</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTclient callback information by sending a MON_CLIENT_CB_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. The polled RTclient responds by sending back a MON_CLIENT_CB_POLL_RESULT message. The response may or may not come back quickly, depending on what the polled RTclient is doing. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a> () to get the response. Each MON_CLIENT_CB_POLL_RESULT message contains nine fields:<ul>
<li>a STR field containing the name of the RTclient<li>an INT4 field containing the number of global read callbacks the polled RTclient has on its connection to RTserver<li>an INT4 field containing the number of global write callbacks the polled RTclient has on its connection to RTserver<li>an INT4 field containing the number of global process callbacks the polled RTclient has on its connection to RTserver<li>an INT4 field containing the number of global queue callbacks the polled RTclient has on its connection to RTserver<li>an INT4 field containing the number of default callbacks the polled RTclient has on its connection to RTserver<li>an INT4 field containing the number of error callbacks the polled RTclient has on its connection to RTserver<li>an INT4 field containing the number of server create callbacks the polled RTclient has<li>an INT4 field containing the number of server destroy callbacks the polled RTclient has There are multiple responses only if client_name is a wildcard or T_IPC_MON_ALL. </ul>
    </td>
  </tr>
</table>
<a name="a59" doxytag="SmartSockets::TipcMon::clientCongestionGetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool SmartSockets::TipcMon::clientCongestionGetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>client_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
clientCongestionGetWatchis used to determine if a T_MT_MON_CLIENT_BUFFER_HIGH_WATER and T_MT_MON_CLIENT_BUFFER_LOW_WATER watch is currently active for a given server process. The client_name argument indicates the client for which the watch is being checked. The srv argument in clientCongestionGetWatch indicates the connection on which the watch is to be checked. <dl compact><dt><b>
Returns: </b><dd>
true if the watch is currently active, false if not. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a56" doxytag="SmartSockets::TipcMon::clientCongestionSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientCongestionSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>client_name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int4&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>high_water</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int4&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>low_water</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>watch_status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
clientCongestionSetWatch is used to initiate and terminate the T_MT_MON_CLIENT_BUFFER_HIGH_WATER and T_MT_MON_CLIENT_BUFFER_LOW_WATER watches. The watch_status argument indicates whether the watch is being initiated or terminated. If the watch is being initiated, the client_name argument indicates the name of the client whose write buffer is being watched. If the watch is being terminated, the client_name argument indicates the name of the client whose write buffer is to no longer be watched. The high_water and low_water arguments specify the high and low water marks for the buffers being monitored. The srv argument in clientCongestionSetWatch indicates the connection on which the watch is to be set. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a53" doxytag="SmartSockets::TipcMon::clientCpuPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientCpuPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>client_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
clientCpuPoll polls for an RTclient's CPU utilization by sending a MON_CLIENT_CPU_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the monitor_scope option. The polled RTclient responds by sending back a MON_CLIENT_CPU_POLL_RESULT message.
<p>
The MON_CLIENT_CPU_POLL_RESULT will have the following grammar:
<p>
str - Client name real4 - Percent CPU utilization (between 0.0 and 100.0)
<p>
There may be multiple responses if client_name is wildcarded or T_IPC_MON_ALL. If there are no clients that match client_name then the poll request is dropped by the RTserver and no responses will be received.
<p>
A value contained in the percent CPU utilization field is less than zero indicates that the client cannot query its OS for this information, or that the client has not yet implemented this functionality. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a62" doxytag="SmartSockets::TipcMon::clientExtPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientExtPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>client_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
clientExtPoll polls for RTclient extension information by sending a MON_CLIENT_EXT_POLL_CALL message to the RTserver. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the monitor_scope option. The RTserver responds by sending back a MON_CLIENT_EXT_POLL_RESULT message.<dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a41" doxytag="SmartSockets::TipcMon::clientGeneralPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientGeneralPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>clientName</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTclient general information by sending a MON_CLIENT_GENERAL_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. The polled RTclient responds by sending back a MON_CLIENT_GENERAL_POLL_RESULT message. The response may or may not come back quickly, depending on what the polled RTclient is doing. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a>:: mainLoop() to get the response.
<p>
Each MON_CLIENT_GENERAL_POLL_RESULT message contains sixteen fields:<ul>
<li>a STR field containing the name of the RTclient<li>a STR field containing the process monitoring identifier (defaults to a major type of license, such as Development_RTmon)<li>a STR field containing the node name the RTclient is running on<li>a STR field containing the user name the RTclient is running under<li>an INT4 field containing the PID of the RTclient<li>a STR field containing the project the RTclient is a part of<li>a STR field containing the name of the RTserver the RTclient is connected to<li>a STR field containing the name of the SmartSockets architecture (such as sun4_solaris)<li>an INT4 field containing the current operating system sbrk value ( the edge of the RTclient' s virtual memory address space)<li>an INT4 field containing the amount of change in the current operating system sbrk value (the edge of the process 's virtual memory address space) since the RTclient started (actually, since the process's first call to any SmartSockets methods)<li>an INT2 field containing the integer number format of the RTclient (really of type T_INT_FORMAT , but stored in an INT2 field to save space)<li>an INT2 field containing the real number format of the RTclient (really of type T_REAL_FORMAT , but stored in an INT2 field to save space)<li>a STR field containing the fully expanded logical connection name of the connection to RTserver<li>an INT4_ARRAY field containing the counted licenses that the RTclient has checked out ( really an array of type T_LICENSE, but stored in an INT4_ARRAY field for portability)<li>a STR_ARRAY field containing the extra licenses that the RTclient has checked out (such as snmp)<li>a STR_ARRAY field containing the names of the subjects that the RTclient is subscribing to There are multiple responses only if client_name is a wildcard or T_IPC_MON_ALL. To poll once for RTserver general information, use serverGeneralPoll. For an example of how MON_CLIENT_GENERAL_POLL_RESULT messages can be used, see the RTmon GDI Client Information window. </ul>
    </td>
  </tr>
</table>
<a name="a55" doxytag="SmartSockets::TipcMon::clientInfoPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientInfoPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>client_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
clientInfoPoll polls for RTclient information by sending a MON_CLIENT_INFO_POLL_CALL message to the RTserver. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the monitor_scope option. The RTserver responds by sending back a MON_CLIENT_INFO_POLL_RESULT message. The MON_CLIENT_INFO_POLL_RESULT message will have the following grammar:
<p>
str - client_name str - ident str - node_name str - user_name int4 - pid str - project str - server_name str - arch int4 - current_sbrk int4 - sbrk_delta_since_startup int2 - int_format int2 - real_format str - logical_conn_name_to_server int4 - number of subscribes for client real4 - Percent CPU utilization (between 0.0 and 100.0) for client <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a37" doxytag="SmartSockets::TipcMon::clientMsgRecvSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientMsgRecvSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>clientName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg_type_name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>watch_status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets whether or not this RTclient is watching received messages in the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to watch all RTclients in the project that match the value of the Monitor_Scope option. clientMsgRecvSetWatch saves the watch status and sends a MON_CLIENT_MSG_RECV_SET_WATCH message to the client_name RTclient. The watch status controls whether or not the RTclient receives a MON_CLIENT_MSG_RECV_STATUS message each time a received message is inserted or deleted from the message queue for the connection to RTserver in the watched RTclient. The watch status is saved internally so the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver. If msg_type_name is T_IPC_MON_ALL, then all message types in the watched RTclient are watched. Each MON_CLIENT_MSG_RECV_STATUS message contains six fields:<ul>
<li>a STR field containing the name of the RTclient<li>a MSG field containing the received message<li>an INT4 field containing whether or not the message was just inserted into or deleted from the connection's message queue (really of type T_BOOL); a value of TRUE means the message was inserted, a value of FALSE means the message was deleted<li>an INT4 field containing the position in the queue where the received message was just inserted or deleted (a value of 0 means the front of the queue)<li>a BINARY field containing a unique 8-byte identifier for the received message; this field is useful for processes that need to accurately track the entire contents of the connection's message queue, such as the RTmon GDI<li>a BINARY field containing an array of unique 8-byte identifiers for all messages in the connection's message queue; this field is useful for processes that need to accurately track the entire contents of the connection's message queue, such as the RTmon GDI In addition to sending a MON_CLIENT_MSG_RECV_STATUS message each time there is a message queue change, the watched RTclient also sends an initial MON_CLIENT_MSG_RECV_STATUS message when the watch status is set to TRUE, so that the RTclient does not have to wait for the next message queue change to receive the first MON_CLIENT_MSG_RECV_STATUS message. To see if this RTclient is watching RTclient received messages, use clientMsgRecvGetWatch. For an example of how MON_CLIENT_MSG_RECV_STATUS messages can be used, see the RTmon GDI Watch Messages Received window. </ul>
    </td>
  </tr>
</table>
<a name="a39" doxytag="SmartSockets::TipcMon::clientMsgSendSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientMsgSendSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>clientName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg_type_name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>watch_status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets whether or not this RTclient is watching sent messages in the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to watch all RTclients in the project that match the value of the Monitor_Scope option. clientMsgSendSetWatch saves the watch status and sends a MON_CLIENT_MSG_SEND_SET_WATCH message to the client_name RTclient. The watch status controls whether or not the RTclient receives a MON_CLIENT_MSG_SEND_STATUS message each time a message is sent to RTserver in the watched RTclient. The watch status is saved internally so that the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver. If msg_type_name is T_IPC_MON_ALL then all message types in the watched RTclient are watched. Each MON_CLIENT_MSG_SEND_STATUS message contains two fields:<ul>
<li>a STR field containing the name of the RTclient<li>a MSG field containing the sent message Unlike most of the other watch categories, the watched RTclient does not also send an initial MON_CLIENT_MSG_SEND_STATUS message when the watch status is set to TRUE. This is because the status message is only sent when a message is sent, and thus there is no current status to use for initialization. To determine if this RTclient is watching RTclient sent messages, use clientMsgSendGetWatch. For an example of how MON_CLIENT_MSG_SEND_STATUS messages can be used, see the RTmon GDI Watch Messages Sent window. </ul>
    </td>
  </tr>
</table>
<a name="a48" doxytag="SmartSockets::TipcMon::clientMsgTrafficPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientMsgTrafficPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>clientName</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTclient message traffic information by sending a MON_CLIENT_MSG_TRAFFIC_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. The polled RTclient responds by sending back a MON_CLIENT_MSG_TRAFFIC_POLL_RESULT message. The response may or may not come back quickly, depending on what the polled RTclient is doing. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response.
<p>
Each MON_CLIENT_MSG_TRAFFIC_POLL_RESULT message contains five fields:<ul>
<li>a STR field containing the name of the RTclient<br>
<li>an INT4 field containing the number of messages the polled RTclient has sent on its connection to RTserver<br>
<li>an INT4 field containing the number of messages the polled RTclient has received on its connection to RTserver<br>
<li>an INT4 field containing the number of bytes the polled RTclient has sent on its connection to RTserver<br>
<li>an INT4 field containing the number of bytes the polled RTclient has received on its connection to RTserver<br>
</ul>
There are multiple responses only if client_name is a wildcard or T_IPC_MON_ALL. To poll once for message traffic information by message type, use clientMsgTypePoll. To poll once for message traffic information by subject, use clientSubjectPoll. To poll once for RTserver message traffic information, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a27">serverMsgTrafficPoll</a>(). <dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcMon.html#a49">clientSubjectPoll</a>, <a class="el" href="classSmartSockets_1_1TipcMon.html#a27">serverMsgTrafficPoll</a> </dl>    </td>
  </tr>
</table>
<a name="a46" doxytag="SmartSockets::TipcMon::clientMsgTypeExPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientMsgTypeExPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>clientName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg_type_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTclient message type information by sending a MON_CLIENT_MSG_TYPE_EX_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. The polled RTclient responds by sending back a MON_CLIENT_MSG_TYPE_EX_POLL_RESULT message. The response may or may not come back quickly, depending on what the polled RTclient is doing. If msg_type_name is T_IPC_MON_ALL, then all message types in the polled RTclient are polled. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_CLIENT_MSG_TYPE_EX_POLL_RESULT message contains one fixed field and fifteen field arrays. The fixed field is a STR field containing the name of the RTclient. The fifteen arrays are:<ul>
<li>a STR_ARRAY field containing the name of each message type<li>an INT4_ARRAY field containing each message type number<li>a STR_ARRAY field containing theach message type grammar<li>an INT4_ARRAY field containing whether or not each message type priority is known (really of type T_BOOL)<li>an INT2_ARRAY field containing the message type priorities (not applicable if the corresponding element in the previous field is FALSE)<li>an INT4_ARRAY field containing the message type delivery modes (really of type T_IPC_DELIVERY_MODE)<li>an INT4_ARRAY field containing the message type user-defined properties<li>an INT4_ARRAY field containing the number of read callbacks the polled RTclient has for each message type on its connection to RTserver<li>an INT4_ARRAY field containing the number of write callbacks the polled RTclient has for each message type on its connection to RTserver<li>an INT4_ARRAY field containing the number of process callbacks the polled RTclient has for each message type on its connection to RTserver<li>an INT4_ARRAY field containing the number of queue callbacks the polled RTclient has for each message type on its connection to RTserver<li>an INT8_ARRAY field containing the number of messages the polled RTclient has sent for each message type on its connection to RTserver<li>an INT8_ARRAY field containing the number of messages the polled RTclient has received for each message type on its connection to RTserver<li>an INT8_ARRAY field containing the number of bytes the polled RTclient has sent for each message type on its connection to RTserver<li>an INT8_ARRAY field containing the number of bytes the polled RTclient has received for each message type on its connection to RTserver There are multiple responses only if client_name is a wildcard or T_IPC_MON_ALL. To poll once for global message traffic information, use clientMsgTrafficPoll. To poll once for message traffic information by subject, use clientSubjectPoll. To poll once for global callback information, use clientCbPoll. <dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcMon.html#a49">clientSubjectPoll</a>, <a class="el" href="classSmartSockets_1_1TipcMon.html#a47">clientCbPoll</a> </dl><dl compact><dt><b>
Since: </b><dd>
SmartSockets 6.7.0 </dl></ul>
    </td>
  </tr>
</table>
<a name="a45" doxytag="SmartSockets::TipcMon::clientMsgTypePoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientMsgTypePoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>clientName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg_type_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTclient message type information by sending a MON_CLIENT_MSG_TYPE_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. The polled RTclient responds by sending back a MON_CLIENT_MSG_TYPE_POLL_RESULT message. The response may or may not come back quickly, depending on what the polled RTclient is doing. If msg_type_name is T_IPC_MON_ALL, then all message types in the polled RTclient are polled. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_CLIENT_MSG_TYPE_POLL_RESULT message contains one fixed field and one or more groups of fifteen fields. The fixed field is a STR field containing the name of the RTclient. The group of fifteen fields is:<ul>
<li>a STR field containing the name of the message type<li>an INT4 field containing the message type number<li>a STR field containing the message type grammar<li>an INT4 field containing whether or not the message type priority is known (really of type T_BOOL)<li>an INT2 field containing the message type priority (not applicable if the previous field is FALSE)<li>an INT4 field containing the message type delivery mode (really of type T_IPC_DELIVERY_MODE)<li>an INT4 field containing the message type user-defined property<li>an INT4 field containing the number of read callbacks the polled RTclient has for this message type on its connection to RTserver<li>an INT4 field containing the number of write callbacks the polled RTclient has for this message type on its connection to RTserver<li>an INT4 field containing the number of process callbacks the polled RTclient has for this message type on its connection to RTserver<li>an INT4 field containing the number of queue callbacks the polled RTclient has for this message type on its connection to RTserver<li>an INT4 field containing the number of messages the polled RTclient has sent for this message type on its connection to RTserver<li>an INT4 field containing the number of messages the polled RTclient has received for this message type on its connection to RTserver<li>an INT4 field containing the number of bytes the polled RTclient has sent for this message type on its connection to RTserver<li>an INT4 field containing the number of bytes the polled RTclient has received for this message type on its connection to RTserver There are multiple responses only if client_name is a wildcard or T_IPC_MON_ALL. To poll once for global message traffic information, use clientMsgTrafficPoll. To poll once for message traffic information by subject, use clientSubjectPoll. To poll once for global callback information, use clientCbPoll.</ul>
<dl compact><dt><b>
Note: </b><dd>
The traffic statistics presented in the result message from this poll are truncated to 31 bits, and may contain an incorrect sign bit on some older servers. This method is provided for compatibility with pre-6.7 servers. When polling newer servers, you should use clientMsgTypeExPoll. </dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcMon.html#a46">clientMsgTypeExPoll</a>, <a class="el" href="classSmartSockets_1_1TipcMon.html#a49">clientSubjectPoll</a>, <a class="el" href="classSmartSockets_1_1TipcMon.html#a47">clientCbPoll</a> </dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="SmartSockets::TipcMon::clientNamesGetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool SmartSockets::TipcMon::clientNamesGetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines whether RTclient is watching RTclient names. <dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcMon.html#a8">clientNamesSetWatch</a>() for more details on watching RTclient names. </dl>    </td>
  </tr>
</table>
<a name="a51" doxytag="SmartSockets::TipcMon::clientNamesNumPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientNamesNumPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
clientNamesNumPoll polls for the number of RTclients in the current project that match the value of the monitor_scope option by sending a MON_CLIENT_NAMES_NUM_POLL_CALL message to the RTserver. The RTserver responds by sending back a MON_CLIENT_NAMES_NUM_POLL_RESULT message.
<p>
The MON_CLIENT_NAMES_NUM_POLL_RESULT message will have the following grammar:
<p>
int4 - number of clients
<p>
The resulting message may have 0 for the number of clients, if no clients match the value of monitor_scope.     </td>
  </tr>
</table>
<a name="a18" doxytag="SmartSockets::TipcMon::clientNamesPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientNamesPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for the RTclient names in the current project that match the value of the Monitor_Scope option by sending a MON_CLIENT_NAMES_POLL_CALL message to RTserver. RTserver responds by sending back a MON_CLIENT_NAMES_POLL_RESULT message. The response should come back quickly. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. The MON_CLIENT_NAMES_POLL_RESULT message contains three fields:<ul>
<li>a STR_ARRAY field containing the current RTclient names<br>
<li>a STR_ARRAY field containing RTclient info strings of the form "ident: <a href="mailto:user@node">user@node</a>" (such as "RTclient: <a href="mailto:ssuser@workstation1">ssuser@workstation1</a>")<br>
<li>a STR_ARRAY field containing the name of the RTserver each RTclient is connected to<br>
 To watch for created and destroyed RTclient names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a8">clientNamesSetWatch</a>() </ul>
    </td>
  </tr>
</table>
<a name="a8" doxytag="SmartSockets::TipcMon::clientNamesSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientNamesSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>watch_status</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Starts or stops watching any RTclient names in the current project that match the value of the Monitor_Scope option. This method saves the watch status and sends a MON_CLIENT_NAMES_SET_WATCH message to RTserver. * The watch status controls whether or not the RTclient receives a MON_CLIENT_NAMES_STATUS message each time an RTclient is created or destroyed. An RTclient is considered created when it connects to RTserver. An RTclient is considered destroyed when it disconnects from RTserver. The watch status is saved internally so that the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver.
<p>
Each MON_CLIENT_NAMES_STATUS message contains five fields:<br>
<ul>
<li>a STR_ARRAY field containing the current RTclient names (unique subjects)<br>
<li>a STR_ARRAY field containing RTclient info strings of the form "ident: <a href="mailto:user@node">user@node</a>" (such as "RTclient: <a href="mailto:ssuser@workstation1">ssuser@workstation1</a>")<br>
<li>a STR_ARRAY field containing the name of the RTserver each RTclient is connected to a STR field containing the name of the created RTclient (or "" if not applicable)<br>
<li>a STR field containing the name of the destroyed RTclient (or "" if not applicable)<br>
</ul>
In addition to sending a MON_CLIENT_NAMES_STATUS message each time an RTclient is created or destroyed, RTserver also sends an initial MON_CLIENT_NAMES_STATUS message when the watch status is set to TRUE, so that the RTclient does not have to wait for the next RTclient name change to receive the first MON_CLIENT_NAMES_STATUS message.
<p>
To determine if this RTclient is watching RTclient names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a7">clientNamesGetWatch</a>(). To poll once for the RTclient names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a18">clientNamesPoll</a>().     </td>
  </tr>
</table>
<a name="a44" doxytag="SmartSockets::TipcMon::clientOptionPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientOptionPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>clientName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>option_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTclient option information by sending a MON_CLIENT_OPTION_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. The polled RTclient responds by sending back a MON_CLIENT_OPTION_POLL_RESULT message. The response may or may not come back quickly, depending on what the polled RTclient is doing. If option_name is T_IPC_MON_ALL, then all options in the polled RTclient are polled. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a> () to get the response. Each MON_CLIENT_OPTION_POLL_RESULT message contains one fixed field followed by one or more groups of five fields. The fixed field is a STR field containing the name of the RTclient. The group of five fields is:<ul>
<li>a STR field containing the name of the option<li>an INT2 field containing the option type (really T_OPT_TYPE)<li>a STR field containing the value of the option, converted to a string like the setopt command displays<li>an INT4 field containing whether or not the option is required to have a value (that is, it cannot be UNKNOWN)<li>a STR_ARRAY field containing the legal values for the option; this array is empty if not applicable There are multiple responses only if client_name is a wildcard or T_IPC_MON_ALL. To poll once for RTserver option information, use serverOptionPoll. </ul>
    </td>
  </tr>
</table>
<a name="a50" doxytag="SmartSockets::TipcMon::clientSubjectExPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientSubjectExPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>clientName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>subject_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTclient subject information by sending a MON_CLIENT_SUBJECT_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. The polled RTclient responds by sending back a MON_CLIENT_SUBJECT_EX_POLL_RESULT message. The response may or may not come back quickly, depending on what the polled RTclient is doing. If subject_name is T_IPC_MON_ALL, then all subjects ever used in the polled RTclient are polled. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_CLIENT_SUBJECT_POLL_RESULT message contains one fixed field followed by five array fields. The fixed field is a STR field containing the name of the RTclient. The five arrays are:<ul>
<li>a STR_ARRAY field containing the name of the subjects<li>an INT8_ARRAY field containing the number of messages the polled RTclient has sent to each subject on its connection to RTserver<li>an INT8_ARRAY field containing the number of messages the polled RTclient has received for each subject on its connection to RTserver<li>an INT8_ARRAY field containing the number of bytes the polled RTclient has sent to each subject on its connection to RTserver<li>an INT8_ARRAY field containing the number of bytes the polled RTclient has received for each subject on its connection to RTserver</ul>
There are multiple responses only if client_name is a wildcard or T_IPC_MON_ALL. To poll once for global message traffic information, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a48">clientMsgTrafficPoll</a>(). To poll once for message traffic information by message type, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a45">clientMsgTypePoll</a>(). <dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcMon.html#a48">clientMsgTrafficPoll</a>, <a class="el" href="classSmartSockets_1_1TipcMon.html#a45">clientMsgTypePoll</a> </dl><dl compact><dt><b>
Since: </b><dd>
SmartSockets 6.7.0 </dl>    </td>
  </tr>
</table>
<a name="a49" doxytag="SmartSockets::TipcMon::clientSubjectPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientSubjectPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>clientName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>subject_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTclient subject information by sending a MON_CLIENT_SUBJECT_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. The polled RTclient responds by sending back a MON_CLIENT_SUBJECT_POLL_RESULT message. The response may or may not come back quickly, depending on what the polled RTclient is doing. If subject_name is T_IPC_MON_ALL, then all subjects ever used in the polled RTclient are polled. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_CLIENT_SUBJECT_POLL_RESULT message contains one fixed field followed by one or more groups of five fields. The fixed field is a STR field containing the name of the RTclient. The group of five fields is:<ul>
<li>a STR field containing the name of the subject<li>an INT4 field containing the number of messages the polled RTclient has sent to this subject on its connection to RTserver<li>an INT4 field containing the number of messages the polled RTclient has received for this subject on its connection to RTserver<li>an INT4 field containing the number of bytes the polled RTclient has sent to this subject on its connection to RTserver<li>an INT4 field containing the number of bytes the polled RTclient has received for this subject on its connection to RTserver</ul>
There are multiple responses only if client_name is a wildcard or T_IPC_MON_ALL. To poll once for global message traffic information, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a48">clientMsgTrafficPoll</a>(). To poll once for message traffic information by message type, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a45">clientMsgTypePoll</a>().
<p>
<dl compact><dt><b>
Note: </b><dd>
The traffic statistics presented in the result message from this poll are truncated to 31 bits, and may contain an incorrect sign bit on some older servers. This method is provided for compatibility with pre-6.7 servers. When polling newer servers, you should use clientSubjectExPoll. </dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcMon.html#a50">clientSubjectExPoll</a>, <a class="el" href="classSmartSockets_1_1TipcMon.html#a48">clientMsgTrafficPoll</a>, <a class="el" href="classSmartSockets_1_1TipcMon.html#a45">clientMsgTypePoll</a> </dl>    </td>
  </tr>
</table>
<a name="a52" doxytag="SmartSockets::TipcMon::clientSubscribeNumPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientSubscribeNumPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>client_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
clientSubscribeNumPoll polls for the number of subjects subscribed to by an RTclient by sending a MON_CLIENT_SUBSCRIBE_NUM_POLL_CALL message to the RTserver. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the monitor_scope option. The RTserver responds by sending back a MON_CLIENT_SUBSCRIBE_NUM_POLL_RESULT message.
<p>
The MON_CLIENT_SUBSCRIBE_NUM_POLL_RESULT message will have the following grammar:
<p>
str_array - list of client names int4_array - number of subscribes per client
<p>
The resulting message may contain arrays of zero length if no clients match the client_name argument. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a40" doxytag="SmartSockets::TipcMon::clientSubscribePoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientSubscribePoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>clientName</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for subjects that the client_name RTclient is subscribing to by sending a MON_CLIENT_SUBSCRIBE_POLL_CALL message to RTserver. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. RTserver responds by sending back a MON_CLIENT_SUBSCRIBE_POLL_RESULT message. The response should come back quickly. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. The MON_CLIENT_SUBSCRIBE_POLL_RESULT message contains one or more groups of two fields:<ul>
<li>a STR field containing the name of the RTclient<li>a STR_ARRAY field containing the names of the current subjects that the RTclient is subscribing to This group of two fields is repeated multiple times only if client_name is a wildcard or T_IPC_MON_ALL. To watch for subjects that an RTclient is subscribing to, use clientSubscribeSetWatch. </ul>
    </td>
  </tr>
</table>
<a name="a31" doxytag="SmartSockets::TipcMon::clientSubscribeSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientSubscribeSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>clientName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>watch_status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets whether or not this RTclient is watching the subjects that the client_name RTclient is subscribing to. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. clientSubscribeSetWatch saves the watch status and sends a MON_CLIENT_SUBSCRIBE_SET_WATCH message to RTserver. The watch status controls whether or not the RTclient receives a MON_CLIENT_SUBSCRIBE_STATUS message each time the watched RTclient starts or stops subscribing to a subject. The watch status is saved internally so that the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver. Each MON_CLIENT_SUBSCRIBE_STATUS message contains four fields:<ul>
<li>a STR field containing the name of the RTclient<li>a STR_ARRAY field containing the names of the current subjects that the RTclient is subscribing to<li>a STR field containing the name of the subject that the RTclient has just started subscribing to ( or "" if not applicable)<li>a STR field containing the name of the subject that the RTclient has just stopped subscribing to ( or "" if not applicable) In addition to sending a MON_CLIENT_SUBSCRIBE_STATUS message each time the watched RTclient starts or stops subscribing to a subject, RTserver also sends an initial MON_CLIENT_SUBSCRIBE_STATUS message (or many messages if a wildcard or T_IPC_MON_ALL is used) when the watch status is set to TRUE , so that the RTclient does not have to wait for the next subscribed subject change to receive the first MON_CLIENT_SUBSCRIBE_STATUS message. To determine if this RTclient is watching the subjects that an RTclient is subscribing to, use clientSubscribeGetWatch. To poll once for the subjects that an RTclient is subscribing to, use clientSubscribePoll. For an example of how MON_CLIENT_SUBSCRIBE_STATUS messages can be used, see the RTmon GDI Watch Client Subjects window. </ul>
    </td>
  </tr>
</table>
<a name="a42" doxytag="SmartSockets::TipcMon::clientTimePoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientTimePoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>clientName</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTclient time information by sending a MON_CLIENT_TIME_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. The polled RTclient responds by sending back a MON_CLIENT_TIME_POLL_RESULT message. The response may or may not come back quickly, depending on what the polled RTclient is doing. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_CLIENT_TIME_POLL_RESULT message contains seven fields:<ul>
<li>a STR field containing the name of the RTclient<li>a REAL8 field containing the current time (the time from TutGetCurrentTime)<li>a STR field containing the current time converted to a string using the format specified in the Time_Format option; the time format from the polled RTclient, not this RTclient, is used<li>a REAL8 field containing the wall time (the time from TutGetWallTime)<li>a STR field containing the wall time converted to a string using the full time format<li>a REAL8 field containing the amount of CPU time used<li>an INT4 field containing the number of frames processed There are multiple responses only if client_name is a wildcard or T_IPC_MON_ALL. To watch RTclient time information, use clientTimeSetWatch. </ul>
    </td>
  </tr>
</table>
<a name="a33" doxytag="SmartSockets::TipcMon::clientTimeSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientTimeSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>clientName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>watch_status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets whether or not this RTclient is watching time information in the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the Monitor_Scope option. clientTimeSetWatch saves the watch status and sends a MON_CLIENT_TIME_SET_WATCH message to the client_name RTclient. The watch status controls whether or not the RTclient receives a MON_CLIENT_TIME_STATUS message each time the current time changes in the watched RTclient. The watch status is saved internally so that the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver. Each MON_CLIENT_TIME_STATUS message contains seven fields:<ul>
<li>a STR field containing the name of the RTclient<li>a REAL8 field containing the current time (the time from TutGetCurrentTime)<li>a STR field containing the current time converted to a string using the format specified in the Time_Format option; the time format from the watched RTclient, not this RTclient, is used<li>a REAL8 field containing the wall time (the time from TutGetWallTime)<li>a STR field containing the wall time converted to a string using the full time format<li>a REAL8 field containing the amount of CPU time used<li>an INT4 field containing the number of frames processed In addition to sending a MON_CLIENT_TIME_STATUS message each time the current time changes, the watched RTclient also sends an initial MON_CLIENT_TIME_STATUS message when the watch status is set to TRUE, so that the RTclient does not have to wait for the next time change to receive the first MON_CLIENT_TIME_STATUS message. To determine if this RTclient is watching RTclient time information, use clientTimeGetWatch. To poll once for RTclient time information, use clientTimePoll. For an example of how MON_CLIENT_TIME_STATUS messages can be used, see the RTmon GDI Watch Client Time window. </ul>
    </td>
  </tr>
</table>
<a name="a65" doxytag="SmartSockets::TipcMon::clientVersionPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::clientVersionPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>client_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
clientVersionPoll polls for an RTclient's version by sending a MON_CLIENT_VERSION_POLL_CALL message to the client_name RTclient. The client_name argument can be the unique subject name of a single RTclient, a wildcarded subject name to match many RTclients, or T_IPC_MON_ALL to poll all RTclients in the project that match the value of the monitor_scope option. The polled RTclient responds by sending back a MON_CLIENT_VERSION_POLL_RESULT message.
<p>
The MON_CLIENT_VERSION_POLL_RESULT will have the following grammar:
<p>
str - Client name int4 - Client version
<p>
There may be multiple responses if client_name is wildcarded or T_IPC_MON_ALL. If there are no clients that match client_name then the poll request is dropped by the RTserver and no responses will be received.<dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl><dl compact><dt><b>
Since: </b><dd>
SmartSockets 6.7.0 </dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="SmartSockets::TipcMon::getIdentStr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* SmartSockets::TipcMon::getIdentStr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the monitoring identification string of this <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a> connection; this identification string is used as a descriptive name for the connection when it is being monitored. It is used as part of a field in these message types:<ul>
<li>MON_CLIENT_NAMES_STATUS<li>MON_SERVER_NAMES_STATUS<li>MON_CLIENT_NAMES_POLL_RESULT<li>MON_CLIENT_NAMES_NUM_POLL_RESULT<li>MON_SERVER_NAMES_POLL_RESULT</ul>
In these message types, the full field has the form "ident: <a href="mailto:user@node">user@node</a>" (e.g. "Primary_RTclient: <a href="mailto:ssuser@workstation1">ssuser@workstation1</a>"). The monitoring identification string is used as ident. By default the monitoring identification string is set to 'RTclient'. This string can be set with the method <a class="el" href="classSmartSockets_1_1TipcMon.html#a3">setIdentStr</a>().     </td>
  </tr>
</table>
<a name="a5" doxytag="SmartSockets::TipcMon::projectNamesGetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool SmartSockets::TipcMon::projectNamesGetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines whether RTclient is watching project name     </td>
  </tr>
</table>
<a name="a15" doxytag="SmartSockets::TipcMon::projectNamesPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::projectNamesPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls once for project names by sending a MON_PROJECT_NAMES_POLL_CALL message to RTserver. RTserver responds by sending back a MON_PROJECT_NAMES_POLL_RESULT message. The response should come back quickly. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. The MON_PROJECT_NAMES_POLL_RESULT message contains one field, a STR_ARRAY field containing the current project names.
<p>
To watch for created and destroyed project names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a6">projectNamesSetWatch</a>().     </td>
  </tr>
</table>
<a name="a6" doxytag="SmartSockets::TipcMon::projectNamesSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::projectNamesSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>watch_status</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start or stop watching project names. This method also saves the watch status internally and sends a MON_PROJECT_NAMES_SET_WATCH message to RTserver. The watch status controls whether or not the RTclient receives a MON_PROJECT_NAMES_STATUS message each time a project is created or destroyed. A project is considered created when the first RTclient in that project connects to RTserver. A project is considered destroyed when the last RTclient in that project disconnects from RTserver. The watch status is saved internally so that the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver.
<p>
Each MON_PROJECT_NAMES_STATUS message contains three fields:<br>
<ul>
<li>a STR_ARRAY field containing the current project names<br>
<li>a STR field containing the name of the created project (or "" if not applicable)<br>
<li>a STR field containing the name of the destroyed project (or "" if not applicable)<br>
</ul>
In addition to sending a MON_PROJECT_NAMES_STATUS message each time a project is created or destroyed, RTserver also sends an initial MON_PROJECT_NAMES_STATUS message when the watch status is set to TRUE, so that the RTclient does not have to wait for the next project name change to receive the first MON_PROJECT_NAMES_STATUS message. To determine if this RTclient is watching project names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a5">projectNamesGetWatch</a>(). To poll once for project names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a15">projectNamesPoll</a>().<dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if this watch has already been set, or if a problem occurs with the RTserver connection. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a25" doxytag="SmartSockets::TipcMon::serverBufferPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverBufferPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>serverName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>connected_process_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTserver message-related buffer information by sending a MON_SERVER_BUFFER_POLL_CALL message to the server_name RTserver. The server_name argument can be the unique subject name of a single RTserver, a wildcarded subject name to match many RTservers, or T_IPC_MON_ALL to poll all RTservers that match the value of the Monitor_Scope option. The buffer information of connected_process_name (which can be either an RTserver or another RTclient in the same project) is polled. The polled RTserver responds by sending back a MON_SERVER_BUFFER_POLL_RESULT message. The response should come back quickly. If connected_process_name is T_IPC_MON_ALL then the buffers in the polled RTserver of all connected processes are polled. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_SERVER_BUFFER_POLL_RESULT message contains one fixed field followed by one or more groups of five fields. The fixed field is a STR field containing the name of the RTserver. The group of five fields is:<ul>
<li>a STR field containing the name of the process RTserver is connected to<li>an INT4 field containing the number of queued incoming message in the RTserver's connection to the connected process<li>an INT4 field containing the number of bytes of data in the queued incoming messages in the RTserver's connection to the connected process<li>an INT4 field containing the number of bytes of data in the read buffer in the RTserver's connection to the connected process<li>an INT4 field containing the number of bytes of data in the write buffer in the RTserver's connection to the connected process There are multiple responses only if server_name is a wildcard or T_IPC_MON_ALL. To poll once for RTclient buffer information, use clientBufferPoll. For an example of how MON_SERVER_BUFFER_POLL_RESULT messages can be used, see the RTmon GDI Server Buffers window. </ul>
    </td>
  </tr>
</table>
<a name="a60" doxytag="SmartSockets::TipcMon::serverCongestionGetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool SmartSockets::TipcMon::serverCongestionGetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>server_name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>connected_process_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
serverCongestionGetWatch is used to determine if a T_MT_MON_SERVER_BUFFER_HIGH_WATER and T_MT_MON_SERVER_BUFFER_LOW_WATER watch is currently active for a given server process. The server_name argument indicates the server for which the watch is being checked. The connected_process_name argument indicates for which process the watch status is being determined. The srv argument in serverCongestionGetWatch indicates the connection on which the watch is to be checked.
<p>
<dl compact><dt><b>
Returns: </b><dd>
true if the watch is currently active, false if not. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a57" doxytag="SmartSockets::TipcMon::serverCongestionSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverCongestionSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>server_name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>connected_process_name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int4&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>high_water</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int4&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>low_water</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>watch_status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
serverCongestionSetWatch is used to initiate and terminate the T_MT_MON_SERVER_BUFFER_HIGH_WATER and T_MT_MON_SERVER_BUFFER_LOW_WATER watches. The watch_status argument indicates whether the watch is being initiated or terminated. If the watch is being initiated, the server_name argument indicates the name of the server to set the watch, and the connected_process_name argument indicates the name of the process whose write buffer is to be watched. If the watch is being terminated, the connected_process_name argument indicates the name of the process whose write buffer is to no longer be watched. The high_water and low_water arguments specify the high and low water marks for the buffers being monitored. The srv argument in serverCongestionSetWatch indicates the connection on which the watch is to be set. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a20" doxytag="SmartSockets::TipcMon::serverConnGetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool SmartSockets::TipcMon::serverConnGetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine whether this RTclient is watching RTserver connections. <dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcMon.html#a21">serverConnSetWatch</a>() for more details on watching RTserver conns. </dl>    </td>
  </tr>
</table>
<a name="a22" doxytag="SmartSockets::TipcMon::serverConnPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverConnPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTserver connections of the RTservers that match the value of the Monitor_Scope option by sending a MON_SERVER_CONN_POLL_CALL message to RTserver. RTserver responds by sending back a MON_SERVER_CONN_POLL_RESULT message. The response should come back quickly. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. The MON_SERVER_CONN_POLL_RESULT message contains four fields (all the array fields have the same number of elements):<ul>
<li>a STR_ARRAY field containing the names of the first RTservers on the connections<li>a STR_ARRAY field containing the names of the second RTservers on the connections<li>a STR_ARRAY field containing the logical connection names of the connections<li>an INT4_ARRAY field containing the weights of the connections (always one) To watch for created and destroyed RTserver connections, use serverConnSetWatch. </ul>
    </td>
  </tr>
</table>
<a name="a21" doxytag="SmartSockets::TipcMon::serverConnSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverConnSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>watch_status</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets whether or not this RTclient is watching RTserver connections of the RTservers that match the value of the Monitor_Scope option. This method saves the watch status and sends a MON_SERVER_CONN_SET_WATCH message to RTserver. The watch status controls whether or not the RTclient receives a MON_SERVER_CONN_STATUS message each time a connection between RTservers is created or destroyed. The watch status is saved internally so that the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver. Each MON_SERVER_CONN_STATUS message contains eight fields (all the array fields have the same number of elements):<ul>
<li>a STR_ARRAY field containing the names of the first RTservers on the connections<br>
<li>a STR_ARRAY field containing the names of the second RTservers on the connections<br>
<li>a STR_ARRAY field containing the logical connection names of the connections<br>
<li>an INT4_ARRAY field containing the weights of the connections (always one)<br>
<li>a STR field containing the name of the first RTserver on the created connection (or "" if not applicable)<br>
<li>a STR field containing the name of the second RTserver on the created connection (or "" if not applicable)<br>
<li>a STR field containing the name of the first RTserver on the destroyed connection (or "" if not applicable)<br>
<li>a STR field containing the name of the second RTserver on the destroyed connection (or "" if not applicable)<br>
</ul>
In addition to sending a MON_SERVER_CONN_STATUS message each time an RTserver connection is created or destroyed, RTserver also sends an initial MON_SERVER_CONN_STATUS message when the watch status is set to TRUE, so that theRTclient does not have to wait for the next RTserver connection change to receive the first MON_SERVER_CONN_STATUS message.
<p>
To determine if this RTclient is watching RTserver connections, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a20">serverConnGetWatch</a>(). To poll once for RTserver connections, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a22">serverConnPoll</a>().     </td>
  </tr>
</table>
<a name="a54" doxytag="SmartSockets::TipcMon::serverCpuPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverCpuPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>server_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
serverCpuPoll polls for a RTserver's CPU utilization by sending a MON_SERVER_CPU_POLL_CALL message to the server_name RTserver. The server_name argument can be the unique subject name of a single RTserver, a wildcarded subject name to match many RTservers, or T_IPC_MON_ALL to poll all RTservers that match the value of the monitor_scope option. The polled RTservers respond by sending back a MON_SERVER_CPU_POLL_RESULT message.
<p>
The MON_SERVER_CPU_POLL_RESULT will have the following grammar:
<p>
str - Server name real4 - Percent CPU utilization (between 0.0 and 100.0)
<p>
There may be multiple responses if server_name is wildcarded or T_IPC_MON_ALL. If there are no servers that match server_name then the poll request is dropped by the RTserver and no responses will be received. A value contained in the percent CPU utilization field is less than zero indicates that the server cannot query its OS for this information, or that the server has not yet implemented this functionality. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a23" doxytag="SmartSockets::TipcMon::serverGeneralPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverGeneralPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>serverName</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTserver general information by sending a MON_SERVER_GENERAL_POLL_CALL message to the server_name RTserver. The server_name argument can be the unique subject name of a single RTserver, a wildcarded subject name to match many RTservers, or T_IPC_MON_ALL to poll all RTservers that match the value of the Monitor_Scope option. The polled RTserver responds by sending back a MON_SERVER_GENERAL_POLL_RESULT message. The response should come back quickly. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_SERVER_GENERAL_POLL_RESULT message contains seventeen fields:<ul>
<li>a STR field containing the name of the RTserver<li>a STR field containing the process monitoring identifier (defaults to<li>a major type of license, such as RTserver)<li>a STR field containing the node name the RTserver is running on<li>a STR field containing the user name the RTserver is running under<li>an INT4 field containing the PID of the RTserver<li>a STR field containing the name of the SmartSockets architecture (such as sun4_solaris)<li>an INT4 field containing the current operating system sbrk value (the edge of the RTserver's virtual memory address space)<li>an INT4 field containing the amount of change in the current operating system sbrk value (the edge of the process's virtual memory address space) since the RTserver started (actually, since the process's first call to any SmartSockets function)<li>an INT2 field containing the integer number format of the RTserver (really of type T_INT_FORMAT, but stored in an INT2 field to save space)<li>an INT2 field containing the real number format of the RTserver (really of type T_REAL_FORMAT, but stored in an INT2 field to save space)<li>a STR field containing the name of the startup command file that the RTserver used at initialization<li>an INT4 field containing whether the RTserver was started with the -no_daemon command-line argument (really of type BOOL)<li>an INT4 field containing whether the RTserver was started with the -cmd_mode command-line argument (really of type BOOL)<li>a STR_ARRAY field containing the names of the RTclients in the same project as the polling RTclient which are directly connected to the RTserver<li>a STR_ARRAY field containing the names of the RTservers which are directly connected to the RTserver<li>a STR_ARRAY field containing the names of the subjects in the same project as the polling RTclient to which the RTserver is subscribing as the result of an RTserver subscribe command<li>a STR_ARRAY field containing the names of the subjects in the same project as the polling RTclient to which the RTserver is subscribing as the result of direct RTclients subscriptions</ul>
There are multiple responses only if server_name is a wildcard or T_IPC_MON_ALL.
<p>
To poll once for RTclient general information, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a41">clientGeneralPoll</a>().
<p>
For an example of how MON_SERVER_GENERAL_POLL_RESULT messages can be used, see the RTmon GDI Server Information window.     </td>
  </tr>
</table>
<a name="a61" doxytag="SmartSockets::TipcMon::serverMaxClientLicensesGetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool SmartSockets::TipcMon::serverMaxClientLicensesGetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>server_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
serverMaxClientLicensesGetWatchis used to determine if a T_MT_MON_MAX_CLIENT_LICENSES watch is currently active for a given server. The server_name argument indicates the server for which the watch is being checked. The srv argument in TipcSrvMonServerMaxClientLicensesGetWatch indicates the connection on which the watch is to be checked.
<p>
<dl compact><dt><b>
Returns: </b><dd>
true if the watch is currently active, false if not. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a58" doxytag="SmartSockets::TipcMon::serverMaxClientLicensesSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverMaxClientLicensesSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>server_name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>watch_status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
serverMaxClientLicensesSetWatch is the method that will be called to initiate and terminate the T_MT_MON_MAX_CLIENT_LICENSES watch. The server_name argument indicates the name of the server to set the watch. The watch_status argument indicates whether the watch is being initiated or terminated. The srv argument in serverMaxClientLicensesSetWatch indicates the connection on which the watch is to be set. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a28" doxytag="SmartSockets::TipcMon::serverMsgTrafficExPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverMsgTrafficExPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>serverName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>connected_process_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTserver message traffic information by sending a MON_SERVER_MSG_TRAFFIC_EX_POLL_CALL message to the server_name RTserver. The server_name argument can be the unique subject name of a single RTserver, a wildcarded subject name to match many RTservers, or T_IPC_MON_ALL to poll all RTservers that match the value of the Monitor_Scope option. The message traffic information of connected_process_name (which can be either an RTserver or another RTclient in the same project) is polled. The polled RTserver responds by sending back a MON_SERVER_MSG_TRAFFIC_EX_POLL_RESULT message. The response should come back quickly. If connected_process_name is T_IPC_MON_ALL then the message traffic in the polled RTserver of all connected processes are polled. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_SERVER_MSG_TRAFFIC_EX_POLL_RESULT message contains one fixed field followed by five field arrays. The fixed field is a STR field containing the name of the RTserver. The five arrays are:<ul>
<li>a STR_ARRAY field containing the names of the process RTserver is connected to<li>an INT8_ARRAY field containing the number of messages the polled RTserver has sent on its connection to the connected processes<li>an INT8_ARRAY field containing the number of messages the polled RTserver has received on its connection to the connected processes<li>an INT8_ARRAY field containing the number of bytes the polled RTserver has sent on its connection to the connected processes<li>an INT8_ARRAY field containing the number of bytes the polled RTserver has received on its connection to the connected processes There are multiple responses only if server_name is a wildcard or T_IPC_MON_ALL. To poll once for RTclient message traffic information, use clientMsgTrafficPoll. <dl compact><dt><b>
Since: </b><dd>
SmartSockets 6.7.0 </dl></ul>
    </td>
  </tr>
</table>
<a name="a27" doxytag="SmartSockets::TipcMon::serverMsgTrafficPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverMsgTrafficPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>serverName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>connected_process_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTserver message traffic information by sending a MON_SERVER_MSG_TRAFFIC_POLL_CALL message to the server_name RTserver. The server_name argument can be the unique subject name of a single RTserver, a wildcarded subject name to match many RTservers, or T_IPC_MON_ALL to poll all RTservers that match the value of the Monitor_Scope option. The message traffic information of connected_process_name (which can be either an RTserver or another RTclient in the same project) is polled. The polled RTserver responds by sending back a MON_SERVER_MSG_TRAFFIC_POLL_RESULT message. The response should come back quickly. If connected_process_name is T_IPC_MON_ALL then the message traffic in the polled RTserver of all connected processes are polled. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_SERVER_MSG_TRAFFIC_POLL_RESULT message contains one fixed field followed by one or more groups of five fields. The fixed field is a STR field containing the name of the RTserver. The group of five fields is:<ul>
<li>a STR field containing the name of the process RTserver is connected to<li>an INT4 field containing the number of messages the polled RTserver has sent on its connection to the connected process<li>an INT4 field containing the number of messages the polled RTserver has received on its connection to the connected process<li>an INT4 field containing the number of bytes the polled RTserver has sent on its connection to the connected process<li>an INT4 field containing the number of bytes the polled RTserver has received on its connection to the connected process There are multiple responses only if server_name is a wildcard or T_IPC_MON_ALL. To poll once for RTclient message traffic information, use clientMsgTrafficPoll. For an example of how MON_SERVER_MSG_TRAFFIC_POLL_RESULT messages can be used, see the RTmon GDI Watch Server Connections window.</ul>
<dl compact><dt><b>
Note: </b><dd>
The traffic statistics presented in the result message from this poll are truncated to 31 bits, and may contain an incorrect sign bit on some older servers. This method is provided for compatibility with pre-6.7 servers. When polling newer servers, you should use serverMsgTrafficExPoll. </dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcMon.html#a28">serverMsgTrafficExPoll</a> </dl>    </td>
  </tr>
</table>
<a name="a9" doxytag="SmartSockets::TipcMon::serverNamesGetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool SmartSockets::TipcMon::serverNamesGetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines whether RTclient is watching RTserver names <dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcMon.html#a10">serverNamesSetWatch</a>() for more details on watching RTserver names. </dl>    </td>
  </tr>
</table>
<a name="a19" doxytag="SmartSockets::TipcMon::serverNamesPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverNamesPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for the RTserver names that match the value of the Monitor_Scope option by sending a MON_SERVER_NAMES_POLL_CALL message to RTserver. RTserver responds by sending back a MON_SERVER_NAMES_POLL_RESULT message. The response should come back quickly. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a> or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. The MON_SERVER_NAMES_POLL_RESULT message contains two fields:<ul>
<li>a STR_ARRAY field containing the current RTserver names<br>
<li>a STR_ARRAY field containing RTserver info strings of the form "ident: <a href="mailto:user@node">user@node</a>" (for example, "RTserver: <a href="mailto:ssuser@workstation1">ssuser@workstation1</a>")<br>
</ul>
To watch for created and destroyed RTserver names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a10">serverNamesSetWatch</a>();     </td>
  </tr>
</table>
<a name="a10" doxytag="SmartSockets::TipcMon::serverNamesSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverNamesSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>watch_status</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start or stop watching RTserver names that match the value of the Monitor_Scope option. This method saves the watch status and sends a MON_SERVER_NAMES_SET_WATCH message to RTserver. The watch status controls whether or not the RTclient receives a MON_SERVER_NAMES_STATUS message each time an RTserver is created or destroyed. An RTserver is considered created when it starts up (and usually connects to other RTservers). An RTserver is considered destroyed when it terminates or disconnects from other RTservers. The watch status is saved internally so that the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver.
<p>
Each MON_SERVER_NAMES_STATUS message contains four fields:<br>
<ul>
<li>a STR_ARRAY field containing the current RTserver names<br>
<li>a STR_ARRAY field containing RTserver info strings of the form "ident: <a href="mailto:user@node">user@node</a>" (for example, "RTserver: <a href="mailto:ssuser@workstation1">ssuser@workstation1</a>")<br>
<li>a STR field containing the name of the created RTserver (or "" if not applicable)<br>
<li>a STR field containing the name of the destroyed RTserver (or "" if not applicable)</ul>
In addition to sending a MON_SERVER_NAMES_STATUS message each time an RTserver is created or destroyed, RTserver also sends an initial MON_SERVER_NAMES_STATUS message when the watch status is set to TRUE, so that the RTclient does not have to wait for the next RTserver name change to receive the first MON_SERVER_NAMES_STATUS message.
<p>
To determine if this RTclient is watching RTserver names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a9">serverNamesGetWatch</a>(). To poll once for RTserver names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a19">serverNamesPoll</a>() .     </td>
  </tr>
</table>
<a name="a26" doxytag="SmartSockets::TipcMon::serverOptionPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverOptionPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>serverName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>option_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTserver option information by sending a MON_SERVER_OPTION_POLL_CALL message to the server_name RTserver. The server_name argument can be the unique subject name of a single RTserver, a wildcarded subject name to match many RTservers, or T_IPC_MON_ALL to poll all RTservers that match the value of the Monitor_Scope option. The polled RTserver responds by sending back a MON_SERVER_OPTION_POLL_RESULT message. The response should come back quickly. If option_name is T_IPC_MON_ALL then all options in the polled RTserver are polled. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_SERVER_OPTION_POLL_RESULT message contains one fixed field followed by one or more groups of five fields. The fixed field is a STR field containing the name of the RTserver. The group of five fields is:<ul>
<li>a STR field containing the name of the option<br>
<li>an INT2 field containing the option type (really T_OPT_TYPE)<br>
<li>a STR field containing the value of the option, converted to a string like the setopt command displays<br>
<li>an INT4 field containing whether or not the option is required to have a value (that is, cannot be UNKNOWN)<br>
<li>a STR_ARRAY field containing the legal values for the option; this array is empty if not applicable.<br>
</ul>
There are multiple responses only if server_name is a wildcard or T_IPC_MON_ALL. To poll once for RTclient option information, use clientOptionPoll.     </td>
  </tr>
</table>
<a name="a29" doxytag="SmartSockets::TipcMon::serverRoutePoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverRoutePoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>serverName</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest_server_name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTserver route information by sending a MON_SERVER_ROUTE_POLL_CALL message to the server_name RTserver. The server_name argument can be the unique subject name of a single RTserver, a wildcarded subject name to match many RTservers, or T_IPC_MON_ALL to poll all RTservers that match the value of the Monitor_Scope option. The route information to the RTserver dest_server_name is polled. The polled RTserver responds by sending back a MON_SERVER_ROUTE_POLL_RESULT message. The response should come back quickly. If dest_server_name is T_IPC_MON_ALL then the routes in the polled RTserver to all other RTservers are polled. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. Each MON_SERVER_ROUTE_POLL_RESULT message contains one fixed field followed by one or more groups of four fields. The fixed field is a STR field containing the name of the RTserver. The group of four fields is:<ul>
<li>a STR field containing the name of the destination RTserver<li>a STR_ARRAY field containing the names of the RTservers which are directly connected to the destination RTserver<li>an INT4 field containing the distance (in connections or hops ) from the polled RTserver to the destination RTserver<li>a STR_ARRAY field containing the names of the RTservers to follow for the shortest path from the polled RTserver to the destination RTserver There are multiple responses only if server_name is a wildcard or T_IPC_MON_ALL. </ul>
    </td>
  </tr>
</table>
<a name="a63" doxytag="SmartSockets::TipcMon::serverStartTimePoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverStartTimePoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>serverName</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTserver start time information by sending a MON_SERVER_START_TIME_POLL_CALL message to the server_name RTserver. The server_name argument can be the unique subject name of a single RTserver, a wildcarded subject name to match many RTservers, or T_IPC_MON_ALL to poll all RTservers that match the value of the Monitor_Scope option. The polled RTserver responds by sending back a MON_SERVER_START_TIME_POLL_RESULT message. The response should come back quickly. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response.
<p>
Each MON_SERVER_START_TIME_POLL_RESULT message contains three fields:<ul>
<li>a STR field containing the name of the RTserver<li>a REAL8 field containing the start time of the RTserver<li>a REAL8 field containing the number of seconds elapsed since RTserver was started</ul>
There are multiple responses only if server_name is a wildcard or T_IPC_MON_ALL.
<p>
<dl compact><dt><b>
Since: </b><dd>
SmartSockets 6.7.0 </dl>    </td>
  </tr>
</table>
<a name="a24" doxytag="SmartSockets::TipcMon::serverTimePoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverTimePoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>serverName</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for RTserver time information by sending a MON_SERVER_TIME_POLL_CALL message to the server_name RTserver. The server_name argument can be the unique subject name of a single RTserver, a wildcarded subject name to match many RTservers, or T_IPC_MON_ALL to poll all RTservers that match the value of the Monitor_Scope option. The polled RTserver responds by sending back a MON_SERVER_TIME_POLL_RESULT message. The response should come back quickly. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response.
<p>
Each MON_SERVER_TIME_POLL_RESULT message contains four fields:<ul>
<li>a STR field containing the name of the RTserver<li>a REAL8 field containing the wall time (the time from TutGetWallTime)<li>a STR field containing the wall time converted to a string using the full time format<li>a REAL8 field containing the amount of CPU time used</ul>
There are multiple responses only if server_name is a wildcard or T_IPC_MON_ALL. To poll once for RTclient time information, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a42">clientTimePoll</a>().     </td>
  </tr>
</table>
<a name="a64" doxytag="SmartSockets::TipcMon::serverVersionPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::serverVersionPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>server_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
serverVersionPoll polls for a RTserver's version by sending a MON_SERVER_VERSION_POLL_CALL message to the server_name RTserver. The server_name argument can be the unique subject name of a single RTserver, a wildcarded subject name to match many RTservers, or T_IPC_MON_ALL to poll all RTservers that match the value of the monitor_scope option. The polled RTservers respond by sending back a MON_SERVER_SERVER_POLL_RESULT message.
<p>
The MON_SERVER_VERSION_POLL_RESULT will have the following grammar:
<p>
str - Server name int4 - Version number
<p>
There may be multiple responses if server_name is wildcarded or T_IPC_MON_ALL. If there are no servers that match server_name then the poll request is dropped by the RTserver and no responses will be received. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcMonException.html">TipcMonException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl><dl compact><dt><b>
Since: </b><dd>
SmartSockets 6.7.0 </dl>    </td>
  </tr>
</table>
<a name="a3" doxytag="SmartSockets::TipcMon::setIdentStr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::setIdentStr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>type_str</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the monitoring identification string of the <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a> connection passed as an argument to the constructor; this identification string is used as a descriptive name for the connection when it is being monitored. It is used as part of a field in these message types:<ul>
<li>MON_CLIENT_NAMES_STATUS<li>MON_SERVER_NAMES_STATUS<li>MON_CLIENT_NAMES_POLL_RESULT<li>MON_CLIENT_NAMES_NUM_POLL_RESULT<li>MON_SERVER_NAMES_POLL_RESULT</ul>
In these message types, the full field has the form "ident: <a href="mailto:user@node">user@node</a>" (e.g. "Primary_RTclient: <a href="mailto:ssuser@workstation1">ssuser@workstation1</a>"). The monitoring identification string is used as ident.     </td>
  </tr>
</table>
<a name="a16" doxytag="SmartSockets::TipcMon::subjectNamesPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::subjectNamesPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for the subject names in the current project that match the value of the Monitor_Scope option by sending a MON_SUBJECT_NAMES_POLL_CALL message to RTserver. RTserver responds by sending back a MON_SUBJECT_NAMES_POLL_RESULT message. The response should come back quickly. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. The MON_SUBJECT_NAMES_POLL_RESULT message contains one field, a STR_ARRAY field containing the current subject names.
<p>
To watch for created and destroyed subject names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a12">subjectNamesSetWatch</a>()     </td>
  </tr>
</table>
<a name="a12" doxytag="SmartSockets::TipcMon::subjectNamesSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::subjectNamesSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>watch_status</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start or stop watching subject names in the current project that match the value of the Monitor_Scope option. This method saves the watch status and sends a MON_SUBJECT_NAMES_SET_WATCH message to RTserver. The watch status controls whether or not the RTclient receives a MON_SUBJECT_NAMES_STATUS message each time a subject is created or destroyed. A subject is considered created when the first RTclient starts subscribing to that subject. A subject is considered destroyed when the last RTclient stops subscribing to that subject. The watch status is saved internally so that the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver.
<p>
Each MON_SUBJECT_NAMES_STATUS message contains three fields:<ul>
<li>a STR_ARRAY field containing the current subject names<br>
<li>a STR field containing the name of the created subject (or "" if not applicable)<br>
<li>a STR field containing the name of the destroyed subject (or "" if not applicable)<br>
 In addition to sending a MON_SUBJECT_NAMES_STATUS message each time a subject is created or destroyed, RTserver also sends an initial MON_SUBJECT_NAMES_STATUS message when the watch status is set to TRUE, so that the RTclient does not have to wait for the next subject name change to receive the first MON_SUBJECT_NAMES_STATUS message.</ul>
To determine if this RTclient is watching subject names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a11">subjectNamesGetWatch</a>(). To poll once for subject names, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a16">subjectNamesPoll</a>().     </td>
  </tr>
</table>
<a name="a13" doxytag="SmartSockets::TipcMon::subjectSubscribeGetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool SmartSockets::TipcMon::subjectSubscribeGetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>subject_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines whether this RTclient is watching the Rtclients that are subscribing to a subject. <dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcMon.html#a14">subjectSubscribeSetWatch</a> </dl>    </td>
  </tr>
</table>
<a name="a17" doxytag="SmartSockets::TipcMon::subjectSubscribePoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::subjectSubscribePoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>dg_name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls once for RTclients subscribing to a subject by sending a MON_SUBJECT_SUBSCRIBE_POLL_CALL message to RTserver. If subject_name is T_IPC_MON_ALL then all subjects in the current project that match the value of the Monitor_Scope option are polled. RTserver responds by sending back a MON_SUBJECT_SUBSCRIBE_POLL_RESULT message. The response should come back quickly. The polling RTclient can use methods such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">TipcSrv::searchType</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">TipcSrv::mainLoop</a>() to get the response. The MON_SUBJECT_SUBSCRIBE_POLL_RESULT message contains groups of two fields:<ul>
<li>a STR field containing the name of the subject<br>
<li>a STR_ARRAY field containing the names of the current RTclients that are subscribing to the subject<br>
</ul>
The group of two fields is repeated multiple times only if subject_name is T_IPC_MON_ALL. To watch for subject subscribers, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a14">subjectSubscribeSetWatch</a>()     </td>
  </tr>
</table>
<a name="a14" doxytag="SmartSockets::TipcMon::subjectSubscribeSetWatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcMon::subjectSubscribeSetWatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>subject_name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>watch_status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start or stop watching the RTclients that are subscribing to a subject. This method saves the watch status and sends a MON_SUBJECT_SUBSCRIBE_SET_WATCH message to RTserver. The watch status controls whether or not the RTclient receives a MON_SUBJECT_SUBSCRIBE_STATUS message each time an RTclient starts or stops subscribing to the subject. The watch status is saved internally so that the RTclient can automatically rewatch all appropriate categories if RTclient has to reconnect to RTserver. If subject_name is T_IPC_MON_ALL then all subjects in the current project that match the value of the Monitor_Scope option are watched.
<p>
Each MON_SUBJECT_SUBSCRIBE_STATUS message contains four fields:<ul>
<li>a STR field containing the name of the subject<br>
<li>a STR_ARRAY field containing the names of the current RTclients that are subscribing to the subject<br>
<li>a STR field containing the name of the RTclient that just started subscribing to the subject (or "" if not applicable)<br>
<li>a STR field containing the name of the RTclient that just stopped subscribing to the subject (or "" if not applicable)<br>
</ul>
In addition to sending a MON_SUBJECT_SUBSCRIBE_STATUS message each time an RTclient starts or stops subscribing to the subject, RTserver also sends an initial MON_SUBJECT_SUBSCRIBE_STATUS message (or many messages if T_IPC_MON_ALL is used) when the watch status is set to TRUE, so that the RTclient does not have to wait for the next subject subscriber change to receive the first MON_SUBJECT_SUBSCRIBE_STATUS message. To determine if this RTclient is watching the RTclients that are subscribing to a subject, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a13">subjectSubscribeGetWatch</a>(). To poll once for the RTclients that are subscribing to a subject, use <a class="el" href="classSmartSockets_1_1TipcMon.html#a17">subjectSubscribePoll</a>().     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="tmon_8h-source.html">tmon.h</a></ul>
<hr><address><small>Generated on Mon Apr 13 16:28:26 2009 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.12 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
