<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SmartSockets::TipcSrv class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.12 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>SmartSockets::TipcSrv  Class Reference</h1><code>#include &lt;<a class="el" href="tsrv_8h-source.html">tsrv.h</a>&gt;</code>
<p>
<p>Inheritance diagram for SmartSockets::TipcSrv::
<p><center><img src="classSmartSockets_1_1TipcSrv.gif" usemap="#SmartSockets::TipcSrv_map" border="0"></center>
<map name="SmartSockets::TipcSrv_map">
<area href="classSmartSockets_1_1TipcConnClient.html" alt="SmartSockets::TipcConnClient" shape="rect" coords="0,56,180,80">
<area href="classSmartSockets_1_1TipcConn.html" alt="SmartSockets::TipcConn" shape="rect" coords="0,0,180,24">
</map>
<a href="classSmartSockets_1_1TipcSrv-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> (const char *unique_subject, const char *server_names, const char *project=(const char *) T_NULL, const char *subject_prefix=(const char *) T_NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a1">TipcSrv</a> (const char *name)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a2">TipcSrv</a> (T_IPC_SRV srv, bool destroyFlag=false)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a3">operator T_IPC_CONN</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a4">operator T_IPC_SRV</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a5">close</a> (T_IPC_SRV_CONN_STATUS close_status=T_IPC_SRV_CONN_NONE)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top><a name="a6" doxytag="SmartSockets::TipcSrv::~TipcSrv"></a>
virtual&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a6">~TipcSrv</a> ()  throw ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destructor.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a7">open</a> (T_IPC_SRV_CONN_STATUS create_status=T_IPC_SRV_CONN_FULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a8">check</a> (T_IO_CHECK_MODE check_mode, real8 timeout)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a9">flush</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a10">getAutoFlushSize</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a11">setAutoFlushSize</a> (int4 auto_flush_size)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a12">trafficGetBytesRecv</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int8&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a13">trafficGetBytesRecv8</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a14">trafficGetBytesSent</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int8&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a15">trafficGetBytesSent8</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a16">trafficGetMsgsRecv</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int8&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a17">trafficGetMsgsRecv8</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a18">trafficGetMsgsSent</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int8&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a19">trafficGetMsgsSent8</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a20">bufferGetReadSize</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a21">bufferGetWriteSize</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual real8&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a22">getTimeout</a> (T_IPC_TIMEOUT timeout) const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a23">setTimeout</a> (T_IPC_TIMEOUT timeout, real8 value)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual sock&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a24">getSocket</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a25">getNumQueued</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual sock&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a26">getXtSource</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a27">setUsernamePassword</a> (const char *username, const char *password)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a28">keepAlive</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">mainLoop</a> (real8 timeout)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a30">insert</a> (<a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;msg, int4 pos=T_IPC_POS_PRIORITY)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a31">next</a> (<a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;msg, real8 timeout)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a32">nextEx</a> (<a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;msg, real8 timeout)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a33">process</a> (<a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;msg)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a34">search</a> (<a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;msg, <a class="el" href="classSmartSockets_1_1TipcConnSearchSelector.html">TipcConnSearchSelector</a> *selObj, real8 timeout)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">searchType</a> (<a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;msg, <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt, real8 timeout)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a36">read</a> (real8 timeout)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a> (const <a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;msg, bool check_server_msg_send=true)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a38">sendRpc</a> (<a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;reply_msg, const <a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;call_msg, real8 timeout=T_TIMEOUT_FOREVER)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a41">print</a> (T_OUT_FUNC func=(T_OUT_FUNC) TutOut) const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual const char *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a42">getPeerUniqueSubject</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual const char *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a43">getNode</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual const char *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a44">getUser</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a45">getPid</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual const char *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a46">getArch</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual T_IPC_SRV_CONN_STATUS&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a47">getStatus</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a48">lock</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a49">unlock</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual int4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a50">getGmdNumPending</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a51">getSubscribe</a> (const char *subject)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a52">setSubscribe</a> (const char *subject, bool recv_status=true)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a53">traverseSubscribe</a> (<a class="el" href="classSmartSockets_1_1TipcSrvSubjTraverser.html">TipcSrvSubjTraverser</a> *travObj)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a54">setSubscribeStd</a> (bool subscribe_status=true)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a55">getSubscribeLb</a> (const char *subject, bool *lb_status_return)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a56">setSubscribeLb</a> (const char *subject, bool subject_status=true, bool lb_status=true)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a57">subjectLbInit</a> (const char *subject)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a58">gmdFileCreate</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a59">gmdFileDelete</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a60">gmdResend</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a61">gmdMsgDelete</a> (<a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;msg)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual uint4&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a62">getGmdMaxSize</a> () const  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a63">setGmdMaxSize</a> (uint4 gmd_max_size)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a64">gmdMsgServerDelete</a> (<a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;msg)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a65">gmdMsgStatus</a> (<a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;msg)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a66">subjectGmdInit</a> (const char *subject)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a67">setProject</a> (const char *project)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>const char *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a68">getProject</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a69">setServerNames</a> (const char *server_names)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a70">setServerNamesList</a> (T_STR_LIST server_names_list)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>T_STR_LIST&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a71">getServerNamesList</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a72">setDefaultSubjectPrefix</a> (const char *default_subject_prefix)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>const char *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a73">getDefaultSubjectPrefix</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a74">setUniqueSubject</a> (const char *unique_subject)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>const char *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a75">getUniqueSubject</a> ()  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a76">setSubscribeCache</a> (const char *subj_name, bool status, int4 flags)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a77">setCredentials</a> (int4 auth_policy_id, void *auth_data, int4 auth_data_len)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1MessageQueueCallBack.html">MessageQueueCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a78">queueCbCreate</a> (const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt, <a class="el" href="classSmartSockets_1_1MessageQueueCallBack.html">MessageQueueCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1ConnectionCallBack.html">ConnectionCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a79">openCbCreate</a> (<a class="el" href="classSmartSockets_1_1ConnectionCallBack.html">ConnectionCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1ConnectionCallBack.html">ConnectionCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a80">closeCbCreate</a> (<a class="el" href="classSmartSockets_1_1ConnectionCallBack.html">ConnectionCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1ErrorCallBack.html">ErrorCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a81">errorCbCreate</a> (<a class="el" href="classSmartSockets_1_1ErrorCallBack.html">ErrorCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a82">encryptCbCreate</a> (const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt, <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a83">decryptCbCreate</a> (const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt, <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a84">defaultCbCreate</a> (<a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a85">processCbCreate</a> (const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt, <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a86">readCbCreate</a> (const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt, <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a87">writeCbCreate</a> (const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt, <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt; <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a88">subjectCbCreate</a> (const char *subject, const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt, <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *implementor, void *arg=NULL)  throw (TipcException)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#a39">write</a> (const char *dest, <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt, bool check_server_msg_send,...)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top><a name="a40" doxytag="SmartSockets::TipcSrv::writeVa"></a>
void&nbsp;</td><td valign=bottom><b>writeVa</b> (const char *dest, <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt, bool check_server_msg_send, va_list var_arg_list)  throw (TipcException)</td></tr>
<tr><td colspan=2><br><h2>Static Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#d0">logAddMt</a> (T_IPC_MT_LOG_TYPE log_type, <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt)  throw (TipcException)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#d1">logRemoveMt</a> (T_IPC_MT_LOG_TYPE log_type, <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;mt)  throw (TipcException)</td></tr>
<tr><td colspan=2><br><h2>Static Protected Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>void T_ENTRY1&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#e0">subjectCbDelegator</a> (T_IPC_CONN connection, T_IPC_SRV_SUBJECT_CB_DATA data, T_CB_ARG arg)</td></tr>
<tr><td nowrap align=right valign=top>void T_ENTRY1&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#e1">openCbDelegator</a> (T_IPC_SRV connection, T_IPC_SRV_OPEN_CB_DATA data, T_CB_ARG arg)</td></tr>
<tr><td nowrap align=right valign=top>void T_ENTRY1&nbsp;</td><td valign=bottom><a class="el" href="classSmartSockets_1_1TipcSrv.html#e2">closeCbDelegator</a> (T_IPC_SRV connection, T_IPC_SRV_CLOSE_CB_DATA data, T_CB_ARG arg)</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Provides the interfaces for a client to connect to an RTserver process. The constructors allow one to either explicitly choose some of the connection parameters, or to create a named connection, which picks up its settings from the SmartSockets command "setnopt" (e.g. <a class="el" href="classSmartSockets_1_1Utilities.html#d1">Utilities::parseCommandString</a>("setnopt c1 server_names tcp:_node:2222"); would set the server_names property of a connection whose name is c1). 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="SmartSockets::TipcSrv::TipcSrv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SmartSockets::TipcSrv::TipcSrv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>unique_subject</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>server_names</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>project</em> = (const char*) T_NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>subject_prefix</em> = (const char*) T_NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a connection object but doesn't establish a connection. To establish a connection, please see <a class="el" href="classSmartSockets_1_1TipcSrv.html#a7">TipcSrv::open</a>(). <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>unique_subject</em>&nbsp;</td><td>
is always used as the sender property of a message sent to RTserver through a given connection. When a connection is first opened to RTserver, it automatically subscribes to its unique subject. RTservers in a cloud do not allow multiple processes to have the same unique subject. </td></tr>
<tr><td valign=top><em>server_names</em>&nbsp;</td><td>
list of rtserver logical connection names following the format: &lt;protocol&gt;:&lt;node&gt;:&lt;port&gt;. This should match the RTserver's conn_names option. If set to NULL, this option defaults to 'tcp:_node:5101' on Windows and 'local:_node' on Solaris. </td></tr>
<tr><td valign=top><em>project</em>&nbsp;</td><td>
is a self-contained unit or partition that prevents unwanted messages from being sent to processes, in that connections in different projects cannot send messages to each other. A connection belongs to only one project, while an RTserver can provide publish-subscribe routing services for one or more projects. If set to NULL, this option defaults to 'rtworks'. </td></tr>
<tr><td valign=top><em>subject_prefix</em>&nbsp;</td><td>
specifies the qualifier to prepend to message subject. names that don't start with /. Subject names are organized in a hierarchical namespace where the components are delimited by /. A subject name that starts with / is called an absolute subject name. All non-absolute subject names have Default_Subject_Prefix prepended to them. If set to NULL, this option defaults to '/'. </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example creates two RTserver connections:<ul>
<li># Connection 1 will connect to an RTserver (rt1) with its conn_names option set to 'tcp:10.134.1.11:4444', with a fail-over backup RTserver (rt2) with its conn_names option set to 'tcp:10.134.1.12:3333'. This connection will use the unique subject '/foo' and the project 'bar', with a default subject prefix of '/'.<li># Connection 2 will connect to an RTserver running on the local machine listening to a conn_names option set to 'tcp:_node'. This connection will use the default unique subject (_&lt;machine&gt;_&lt;pid&gt;), the default project (rtworks), and a default_subject_prefix of '/leo/'. <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keywordtype">int</font> main()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> c1 (<font class="stringliteral">"/foo"</font>,
                 <font class="stringliteral">"tcp:10.134.1.11:4444,tcp:10.134.1.12:3333"</font>,
                 <font class="stringliteral">"foo"</font>);
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> c2 ((<font class="keyword">const</font> <font class="keywordtype">char</font>*)0,(<font class="keyword">const</font> <font class="keywordtype">char</font>*)0,(<font class="keyword">const</font> <font class="keywordtype">char</font>*)0,<font class="stringliteral">"/leo/"</font>);
     c1.open();
     c2.open();
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> </ul>
</dl>    </td>
  </tr>
</table>
<a name="a1" doxytag="SmartSockets::TipcSrv::TipcSrv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SmartSockets::TipcSrv::TipcSrv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a "named" connection object. This connection will use "named" option values. <dl compact><dt><b>
Example:</b><dd>
 The following example creates two RTserver connections:<ul>
<li># Connection 1 will connect to an RTserver (rt1) with its conn_names option set to 'tcp:10.134.1.11:4444', with a fail-over backup RTserver (rt2) with its conn_names option set to 'tcp:10.134.1.12:3333'. This connection will use the unique subject '/foo' and the project 'bar', with a default subject prefix of '/'.<li># Connection 2 will connect to an RTserver running on the local machine listening to a conn_names option set to 'tcp:_node'. This connection will use the default unique subject (_&lt;machine&gt;_&lt;pid&gt;), the default project (rtworks), and a default_subject_prefix of '/leo/'. <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keywordtype">int</font> main()
 {
   <font class="keywordflow">try</font>
   {
     Utilities::parseCommandString(<font class="stringliteral">"setnopt c1 unique_subject /foo;"</font>
      <font class="stringliteral">"setnopt c1 server_names tcp:10.134.1.11:4444,tcp:10.134.1.12:3333;"</font>
                                   <font class="stringliteral">"setnopt c1 project bar"</font>);

     Utilities::parseCommandString(
                             <font class="stringliteral">"setnopt c2 default_subject_prefix /leo/"</font>);

     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> c1 (<font class="stringliteral">"c1"</font>);
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> c2 (<font class="stringliteral">"c2"</font>);
     c1.open();
     c2.open();
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> </ul>
</dl><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>name</em>&nbsp;</td><td>
- named option value </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="SmartSockets::TipcSrv::TipcSrv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SmartSockets::TipcSrv::TipcSrv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IPC_SRV&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>srv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>destroyFlag</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
constructor from the C type T_IPC_SRV. This constructor is used internally by the API. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>srv</em>&nbsp;</td><td>
C structure created with TipcSrvConnCreate(). </td></tr>
<tr><td valign=top><em>destroyFlag</em>&nbsp;</td><td>
flag that determines whether or not the destructor destroys the C structure. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a20" doxytag="SmartSockets::TipcSrv::bufferGetReadSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int4 SmartSockets::TipcSrv::bufferGetReadSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the total number of bytes in a connection's read buffer.
<p>
<dl compact><dt><b>
Returns: </b><dd>
the total number of bytes in a connection's read buffer. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a63">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a21" doxytag="SmartSockets::TipcSrv::bufferGetWriteSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int4 SmartSockets::TipcSrv::bufferGetWriteSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the total number of bytes in a connection's write buffer.
<p>
<dl compact><dt><b>
Returns: </b><dd>
the total number of bytes in a connection's write buffer. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a64">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="SmartSockets::TipcSrv::check"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool SmartSockets::TipcSrv::check </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IO_CHECK_MODE&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>check_mode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timeout</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks if data can be read from or written to connection. This is a low level method that is only used in advanced publish and subscribe applications. This method is normally called by <a class="el" href="classSmartSockets_1_1TipcSrv.html#a9">flush</a>() and <a class="el" href="classSmartSockets_1_1TipcSrv.html#a36">read</a>(). <dl compact><dt><b>
Warning: </b><dd>
This method may attempt to automatically create a connection to RTserver. If the connection has a warm state, <a class="el" href="classSmartSockets_1_1TipcSrv.html#a8">check</a>() sleeps for timeout seconds and returns false. </dl><dl compact><dt><b>
Returns: </b><dd>
whether or not the data is ready. </dl><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>check_mode</em>&nbsp;</td><td>
- value for the check mode. Use T_IO_CHECK_READ if data can be read or T_IO_CHECK_WRITE to check if data can be written. </td></tr>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
- number of seconds to wait for a result. </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a4">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a5" doxytag="SmartSockets::TipcSrv::close"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::close </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IPC_SRV_CONN_STATUS&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>close_status</em> = T_IPC_SRV_CONN_NONE          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Closes a connection. There are two ways to close the connection to RTserver. A full closure removes all the connection's RTserver-related information. Once this has occurred, the connection can continue as if it had never been connected at all to RTserver. The other mode of close is a warm closure. A warm closure keeps as much RTserver-related information as possible. Once this has occurred, the connection can easily reconnect to RTserver in the future and pick up where it left off. After a warm destroy, the connection can even partially operate as if it were still connected to RTserver. Messages can be sent, and they are buffered until a full connection to RTserver is created again. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>close_status</em>&nbsp;</td><td>
- whether to keep a warm connection to RTserver (use T_IPC_SRV_CONN_WARM) or fully destroy the connection to RTserver (use T_IPC_SRV_CONN_NONE) throw <a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a> if the operation fails. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a80" doxytag="SmartSockets::TipcSrv::closeCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1ConnectionCallBack.html">ConnectionCallBack</a>&gt;* SmartSockets::TipcSrv::closeCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1ConnectionCallBack.html">ConnectionCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a close connection callback. Close callbacks are called when this object either loses or explicitly closes a connection to RTserver.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
a connection callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows how to create a close callback that is invoked once when the server connection is closed, and then deactivated. <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;

 <font class="keyword">class </font>MyConnCb : <font class="keyword">public</font> ConnectionCallBack
 {
   <font class="keyword">public</font>:
     <font class="keyword">virtual</font> <font class="keywordtype">void</font> onConnection (
        CallBack &lt; ConnectionCallBack &gt; * callBack,
        TipcSrv &amp; connection,
        ConnStatus oldConnStatus,
        ConnStatus newConnStatus)
     {
       <font class="keyword">const</font> <font class="keywordtype">char</font>* arg = (<font class="keyword">const</font> <font class="keywordtype">char</font>*) callBack-&gt;getArgument();
       cout &lt;&lt; <font class="stringliteral">" in conn CB close() - "</font> &lt;&lt; arg &lt;&lt; endl;
     }
 };
 <font class="keywordtype">int</font> main ()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/foo"</font>,<font class="stringliteral">"tcp:_node"</font>);
     MyConnCb* myCb = <font class="keyword">new</font> MyConnCb();
     CallBack&lt;ConnectionCallBack&gt;* cb = srv.closeCbCreate(myCb,<font class="stringliteral">"s1"</font>);
     srv.open();

     srv.close();

     <font class="comment">// This should disable the callback.</font>
     cb-&gt;destroy();
     srv.open();
     srv.close();
     <font class="keyword">delete</font> myCb;
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> Here is the output for the code: <div class="fragment"><pre>

       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;
        in conn CB close() - s1
       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;

       </pre></div> </dl>    </td>
  </tr>
</table>
<a name="e2" doxytag="SmartSockets::TipcSrv::closeCbDelegator"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void T_ENTRY1 SmartSockets::TipcSrv::closeCbDelegator </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IPC_SRV&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>connection</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_IPC_SRV_CLOSE_CB_DATA&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_CB_ARG&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static, protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delegator method for close connection callbacks. Will be called when the callback is triggered and will in turn call the callback's handler method.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>connection</em>&nbsp;</td><td>
the connection on which the callback was triggered </td></tr>
<tr><td valign=top><em>data</em>&nbsp;</td><td>
the connection callback data (contains the message to which connection status information for which the callback applies) </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
the callback object </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a83" doxytag="SmartSockets::TipcSrv::decryptCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a>&gt;* SmartSockets::TipcSrv::decryptCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a callback that is called after all the read callback objects are called and after the <a class="el" href="classSmartSockets_1_1TipcMtEncrypt.html">TipcMtEncrypt</a> object is called. The Decrypt callback objects are called when a new message is read from the connection's socket, which occurs in the <a class="el" href="classSmartSockets_1_1TipcSrv.html#a36">read</a>(). First, the read callbacks are called. Then the message is decrypted. Finally, the decrypt callbacks are called. Decrypt callbacks are useful for processing messages, after they have been decrypted, to do the exact opposite of what was done during the encrypt callbacks. A decrypt callback is usually created for a specific message type and connection. If the message type is null, then global decrypt callback is created for all message types on that connection.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
the message type for the callback </td></tr>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
a decryption callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows an encrypt callback that gets triggered for outgoing messages: <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;

 <font class="keyword">class </font>MyCb : <font class="keyword">public</font> MessageCallBack
 {
   <font class="keyword">public</font>:
     <font class="keywordtype">void</font> onMessage (CallBack &lt;MessageCallBack&gt; * cb,
                      TipcMsg &amp; message,
                      TipcConn &amp; connection)
     {
       cout &lt;&lt; <font class="stringliteral">"in onMessage(); - (Decrypt Cb) "</font> &lt;&lt; endl;
     }
 };
 <font class="keywordtype">int</font> main ()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/foo"</font>,<font class="stringliteral">"tcp:_node"</font>);
     MyCb* myCb = <font class="keyword">new</font> MyCb();
     srv.open();
     TipcMt mt(T_MT_INFO);
     mt.setKey((<font class="keyword">const</font> <font class="keywordtype">void</font>*)<font class="stringliteral">"a"</font>,2);
     CallBack&lt;MessageCallBack&gt;* cb = srv.decryptCbCreate(mt, myCb);

     TipcMsg msg(T_MT_INFO,<font class="stringliteral">"/foo"</font>);
     msg &lt;&lt; <font class="stringliteral">"test"</font>;
     srv.send(msg);
     srv.mainLoop(10.0);
     <font class="comment">// This should disable the callback.</font>
     cb-&gt;destroy();

     <font class="keyword">delete</font> myCb;
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> Here's the output of this code: <div class="fragment"><pre>
       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;
       in onMessage(); - (Decrypt Cb)

       </pre></div> </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a32">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a84" doxytag="SmartSockets::TipcSrv::defaultCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a>&gt;* SmartSockets::TipcSrv::defaultCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a default callback that is invoked if no other process callbacks are called. Default callback objects are called by <a class="el" href="classSmartSockets_1_1TipcSrv.html#a33">process</a>() when there are no process callbacks for the type of message being processed.
<p>
Default callbacks are useful for processing unexpected message types or for generic processing of most message types.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
a messagen callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows a default, a process and a subject callbacks. outgoing messages: <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;

 <font class="keyword">class </font>MyCb : <font class="keyword">public</font> MessageCallBack
 {
   <font class="keyword">public</font>:
     <font class="keywordtype">void</font> onMessage (CallBack &lt;MessageCallBack&gt; * cb,
                      TipcMsg &amp; msg,
                      TipcConn &amp; connection)
     {
       <font class="keyword">const</font> <font class="keywordtype">char</font>* arg = (<font class="keyword">const</font> <font class="keywordtype">char</font>*) cb-&gt;getArgument();
       cout &lt;&lt; <font class="stringliteral">"in onMessage(); - ("</font> &lt;&lt; arg &lt;&lt; <font class="stringliteral">"); "</font>
            &lt;&lt; <font class="stringliteral">"message type = &lt;"</font> &lt;&lt; msg.getType().getName()
            &lt;&lt; <font class="stringliteral">"&gt; "</font> &lt;&lt; endl;
     }
 };
 <font class="keywordtype">int</font> main ()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/foo"</font>,<font class="stringliteral">"tcp:_node"</font>);
     MyCb* myCb = <font class="keyword">new</font> MyCb();
     srv.open();
     srv.setSubscribe(<font class="stringliteral">"/bar"</font>);
     TipcMt mt(T_MT_INFO);
     CallBack&lt;MessageCallBack&gt;* cb1 = srv.defaultCbCreate(myCb,<font class="stringliteral">"default"</font>);

     CallBack&lt;MessageCallBack&gt;* cb2 = srv.processCbCreate(mt,
                                                         myCb,<font class="stringliteral">"process"</font>);

     TipcMt nullMt((T_IPC_MT)NULL);
     CallBack&lt;MessageCallBack&gt;* cb3 = srv.subjectCbCreate(<font class="stringliteral">"/fo*"</font>,nullMt,
                                                         myCb,<font class="stringliteral">"subject"</font>);


     TipcMsg msg(T_MT_INFO,<font class="stringliteral">"/foo"</font>);
     msg &lt;&lt; <font class="stringliteral">"test"</font>;
     <font class="comment">// trigger the process and subject callbacks.</font>
     srv.send(msg);

     msg.setType(TipcMt::lookup(T_MT_NUMERIC_DATA));
     msg.setDest(<font class="stringliteral">"/bar"</font>);
     <font class="comment">// trigger the default callback.</font>
     srv.send(msg);

     srv.mainLoop(10.0);
     <font class="comment">// This should disable the callback.</font>
     cb1-&gt;destroy();
     cb2-&gt;destroy();
     cb3-&gt;destroy();

     <font class="keyword">delete</font> myCb;
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> Here's the output of this code: <div class="fragment"><pre>

       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;
       in onMessage(); - (process); message type = &lt;info&gt;
       in onMessage(); - (subject); message type = &lt;info&gt;
       in onMessage(); - (default); message type = &lt;numeric_data&gt;

       </pre></div> </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a33">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a82" doxytag="SmartSockets::TipcSrv::encryptCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a>&gt;* SmartSockets::TipcSrv::encryptCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a callback that is invoked before the <a class="el" href="classSmartSockets_1_1TipcMtEncrypt.html">TipcMtEncrypt</a> encryption callbacks and before the write callbacks are invoked. EncryptionCallBack objects are invoked when a message is buffered to be sent through the connection's socket, which occurs in <a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a>(). These objects are invoked before the write callback objects are invoked.
<p>
After these objects are invoked, the message is encrypted using the encryption object registered by <a class="el" href="classSmartSockets_1_1TipcMt.html#a26">TipcMt::setEncryptObj</a>() and then the write callbacks are invoked.
<p>
Encrypt callbacks are useful for processing of messages before they are encrypted and sent. An encrypt callback is usually created for a specific message type and connection. If the message type is null (e.g. <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> nullMt((T_IPC_MT)NULL);), then global encrypt callback is created for all message types on that connection.
<p>
<dl compact><dt><b>
Warning: </b><dd>
After a message has been encrypted, it is put into a T_MT_ENCRYPT_MESSAGE as a binary payload; therefore, no write callback objects will be triggered for that message type. </dl><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
the message type for the callback </td></tr>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
an encryption callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows an encrypt callback that gets triggered for outgoing messages: <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;

 <font class="keyword">class </font>MyCb : <font class="keyword">public</font> MessageCallBack
 {
   <font class="keyword">public</font>:
     <font class="keywordtype">void</font> onMessage (CallBack &lt;MessageCallBack&gt; * cb,
                      TipcMsg &amp; message,
                      TipcConn &amp; connection)
     {
       cout &lt;&lt; <font class="stringliteral">"in onMessage(); - (Encrypt Cb) "</font> &lt;&lt; endl;
     }
 };
 <font class="keywordtype">int</font> main ()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/foo"</font>,<font class="stringliteral">"tcp:_node"</font>);
     MyCb* myCb = <font class="keyword">new</font> MyCb();
     srv.open();
     TipcMt mt(T_MT_INFO);
     mt.setKey((<font class="keyword">const</font> <font class="keywordtype">void</font>*)<font class="stringliteral">"a"</font>,2);
     CallBack&lt;MessageCallBack&gt;* cb = srv.encryptCbCreate(mt, myCb);

     TipcMsg msg(T_MT_INFO,<font class="stringliteral">"/foo"</font>);
     msg &lt;&lt; <font class="stringliteral">"test"</font>;
     srv.send(msg);
     srv.flush();
     <font class="comment">// This should disable the callback.</font>
     cb-&gt;destroy();

     <font class="keyword">delete</font> myCb;
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> Here's the output of this code: <div class="fragment"><pre>
       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;
       in onMessage(); - (Encrypt Cb)

       </pre></div> </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a31">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a81" doxytag="SmartSockets::TipcSrv::errorCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1ErrorCallBack.html">ErrorCallBack</a>&gt;* SmartSockets::TipcSrv::errorCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1ErrorCallBack.html">ErrorCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an error callback. <a class="el" href="classSmartSockets_1_1ErrorCallBack.html">ErrorCallBack</a> objects are invoked whenever this object loses a connection to RTserver. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
an error callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows how to create an error callback that is activated by killing the RTserver. <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;

 <font class="keyword">class </font>MyErrCb : <font class="keyword">public</font> ErrorCallBack
 {
   <font class="keyword">public</font>:
     <font class="keyword">virtual</font> <font class="keywordtype">void</font> onError (
        CallBack &lt; ErrorCallBack &gt; * callBack,
        Exception&amp; e,
        TipcConn &amp;conn)
     {
       <font class="keyword">const</font> <font class="keywordtype">char</font>* arg = (<font class="keyword">const</font> <font class="keywordtype">char</font>*) callBack-&gt;getArgument();
       cout &lt;&lt; <font class="stringliteral">" in error cb() - "</font> &lt;&lt; arg <font class="stringliteral">" "</font> &lt;&lt; e.what() &lt;&lt; endl;
     }
 };
 <font class="keywordtype">int</font> main ()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/foo"</font>,<font class="stringliteral">"tcp:_node"</font>);
     MyErrCb* myCb = <font class="keyword">new</font> MyErrCb();
     srv.open();

     CallBack&lt;ErrorCallBack&gt;* cb = srv.errorCbCreate(myCb,<font class="stringliteral">"s1"</font>);
     System::runCommand(<font class="stringliteral">"rtserver -stop &gt; output"</font>);
     srv.mainLoop(10.0);

     cb-&gt;destroy();
     <font class="keyword">delete</font> myCb;
   }
   <font class="keywordflow">catch</font> (Exception&amp; e)
   {
     cout &lt;&lt; <font class="stringliteral">"exception caught: "</font> &lt;&lt; e.what() &lt;&lt; endl;
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> Here is the output for the code: <div class="fragment"><pre>

       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;
       TAL-SS-00104-W Lost connection to RTserver: error code = 10
       TAL-SS-00071-I Waiting before reconnecting
       TAL-SS-00097-I Attempting to reconnect to RTserver
       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00090-I Could not connect to &lt;tcp:_node&gt; RTserver
       TAL-SS-00093-I Skipping starting &lt;tcp:_node&gt; RTserver
       TAL-SS-00098-I Cannot reconnect to RTserver
        in error cb() - s1 server not connected
       exception caught: end of file

       </pre></div> </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a30">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="SmartSockets::TipcSrv::flush"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::flush </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flushes buffered outgoing messages on the connection. <dl compact><dt><b>
Warning: </b><dd>
This method may attempt to automatically create a connection to RTserver. If the connection has a warm state, an exception is thrown immediately. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if no connection exists or if a network error occurs. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a5">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a46" doxytag="SmartSockets::TipcSrv::getArch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual const char* SmartSockets::TipcSrv::getArch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the architecture name of the connected server. The string returned is equivalent to the value of the environment variable RTARCH in the machine where the RTserver is used (e.g. sun4_solaris on Solaris, i86_w32 on Intel Windows 32 boxes). <dl compact><dt><b>
Warning: </b><dd>
The string returned should not be changed; it belongs to this object. </dl><dl compact><dt><b>
Returns: </b><dd>
the architecture name to the connected server </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a43">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a10" doxytag="SmartSockets::TipcSrv::getAutoFlushSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int4 SmartSockets::TipcSrv::getAutoFlushSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the auto_flush_size of a connection to the RTserver. The auto flush size is used to control how much outgoing data (in bytes) are buffered before being automatically flushed to RTserver. The default for the auto flush size is 8192 bytes. <dl compact><dt><b>
Returns: </b><dd>
the auto flush size that is set. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a6">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a73" doxytag="SmartSockets::TipcSrv::getDefaultSubjectPrefix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* SmartSockets::TipcSrv::getDefaultSubjectPrefix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the connections default subject prefix return the default subject prefix of the connection <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a62" doxytag="SmartSockets::TipcSrv::getGmdMaxSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual uint4 SmartSockets::TipcSrv::getGmdMaxSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the GMD area's maximum size of the connection to RTserver. A GMD area holds guaranteed message delivery information for both incoming and outgoing messages. There are two types of guaranteed message delivery: file-based GMD and memory-only GMD.
<p>
For file-based GMD this limit is the maximum file size, and for memory-only GMD this limit is the maximum amount of memory allowed. The default GMD area maximum size is 0, which means that no GMD area maximum size limit checking is performed. The connection GMD area maximum size and the connection delivery timeout can be used to constrain the amount of system resources used for GMD by space and by time.
<p>
If the connection GMD area maximum size is exceeded, then no further messages can be sent with guaranteed delivery (<a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a>() throws an exception with the SmartSockets error number to set to T_ERR_VAL_TOO_LARGE) until some unacknowledged previously sent messages are acknowledged.
<p>
<dl compact><dt><b>
Returns: </b><dd>
the maximum size of the GMD area in bytes </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a51">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a50" doxytag="SmartSockets::TipcSrv::getGmdNumPending"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int4 SmartSockets::TipcSrv::getGmdNumPending </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines the number of outgoing GMD messages still pending on the connection. This method gets the number of GMD messages published to RTserver that have not been acknowledged nor explicitly deleted from the GMD area. Messages are deleted from the GMD area when a GMD_ACK message is received and when a GMD_FAILURE message is processed. TipcSrvGetGmdNumPending may attempt to automatically create a connection to RTserver. If the connection's state is warm, this method gets the number of pending GMD messages from the warm connection. <dl compact><dt><b>
Returns: </b><dd>
the number of GMD messages pending </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a54">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a43" doxytag="SmartSockets::TipcSrv::getNode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual const char* SmartSockets::TipcSrv::getNode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines the node name of the connected server. <dl compact><dt><b>
Returns: </b><dd>
the node information </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a40">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a25" doxytag="SmartSockets::TipcSrv::getNumQueued"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int4 SmartSockets::TipcSrv::getNumQueued </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the number of queued messages from the connection. A connection has a priority queue of incoming messages. Messages are inserted into the queue either explicitly or implicitly. Explicit insertions can be made by calling the <a class="el" href="classSmartSockets_1_1TipcSrv.html#a30">insert</a>() method. Implicit insertions happen whenever data is read using the <a class="el" href="classSmartSockets_1_1TipcSrv.html#a36">read</a>() or <a class="el" href="classSmartSockets_1_1TipcSrv.html#a31">next</a>() methods. <dl compact><dt><b>
Returns: </b><dd>
the number of queued messages </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a13">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a42" doxytag="SmartSockets::TipcSrv::getPeerUniqueSubject"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual const char* SmartSockets::TipcSrv::getPeerUniqueSubject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines the unique subject of the connected server. <dl compact><dt><b>
Returns: </b><dd>
the RTserver's unique subject </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a39">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a45" doxytag="SmartSockets::TipcSrv::getPid"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int4 SmartSockets::TipcSrv::getPid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines the process ID of the connected server. <dl compact><dt><b>
Returns: </b><dd>
the Pid information </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a42">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a68" doxytag="SmartSockets::TipcSrv::getProject"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* SmartSockets::TipcSrv::getProject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the connections project. <dl compact><dt><b>
Returns: </b><dd>
the project name </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a71" doxytag="SmartSockets::TipcSrv::getServerNamesList"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> T_STR_LIST SmartSockets::TipcSrv::getServerNamesList </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the connections server names list. <dl compact><dt><b>
Returns: </b><dd>
the connections server names list </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a24" doxytag="SmartSockets::TipcSrv::getSocket"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual sock SmartSockets::TipcSrv::getSocket </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the socket handle of the connection. A socket is an operating system device which provides a communication link to another process. All data sent to and received from the connection is transmitted on this socket. <dl compact><dt><b>
Returns: </b><dd>
the socket information throw <a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a> if the socket information could not be retrieved </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a12">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a47" doxytag="SmartSockets::TipcSrv::getStatus"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual T_IPC_SRV_CONN_STATUS SmartSockets::TipcSrv::getStatus </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines the status of the connection. A connection status of T_IPC_SRV_CONN_FULL indicates that the connection has been opened to RTserver. A connection status of T_IPC_SRV_CONN_WARM indicates that the connection has a warm state. connection to RTserver. A connection status of T_IPC_SRV_CONN_NONE indicates that the <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a> object does not have a connection to RTserver. <dl compact><dt><b>
Returns: </b><dd>
the enum value of the T_IPC_SRV_CONN_STATUS. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a51" doxytag="SmartSockets::TipcSrv::getSubscribe"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool SmartSockets::TipcSrv::getSubscribe </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>subject</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines if this object is subscribing to a subject. The subscribe status controls whether the RTclient receives messages published (sent) to that subject. If the subscribe status of subject is true, the connection receives messages with subject as their destination that are sent to RTserver. To start or stop subscribing to a subject, use <a class="el" href="classSmartSockets_1_1TipcSrv.html#a52">setSubscribe</a>(). To find out if this connection is subscribing to a subject including load balancing information, use <a class="el" href="classSmartSockets_1_1TipcSrv.html#a55">getSubscribeLb</a>(). <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>subject</em>&nbsp;</td><td>
- subject name </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
a boolean whether the client is subscribed to the subject </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a55" doxytag="SmartSockets::TipcSrv::getSubscribeLb"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool SmartSockets::TipcSrv::getSubscribeLb </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>subject</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>lb_status_return</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines if a connection is subscribing to a subject, including load balancing information. <dl compact><dt><b>
an subject - subject name</b><dd>
 </dl><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>lb_status_return</em>&nbsp;</td><td>
- pointer to boolean indicating the load balancing status </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
a boolean, whether the client is subscribed to a subject or not </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a22" doxytag="SmartSockets::TipcSrv::getTimeout"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual real8 SmartSockets::TipcSrv::getTimeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IPC_TIMEOUT&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>timeout</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets a timeout property from the connection to RTserver. The timeout properties control how often (in seconds) the connection to RTserver is checked for possible network failures. The timeout properties of the connection to RTserver are also available in the options Server_Read_Timeout, Server_Write_Timeout, Server_Keep_Alive_Timeout, and Server_Delivery_Timeout. For the connection to RTserver, the default read timeout is 30.0 seconds, the default write timeout is 30.0 seconds, the default keep alive timeout is 15.0 seconds, and the default delivery timeout is 30.0 seconds. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
Determines the type of timeout to retrieve:<ul>
<li>If timeout is T_IPC_TIMEOUT_READ, the read timeout of the connection is obtained. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a8">check</a>() uses the read timeout to control how often data is expected to be available for reading on the connection. A read timeout property of 0.0 disables checking for read timeouts.<li>If timeout is T_IPC_TIMEOUT_WRITE, the write timeout of the connection is obtained. A write timeout property of 0.0 disables checking for write timeouts.<li>If timeout is T_IPC_TIMEOUT_KEEP_ALIVE, the keep alive timeout of the connection is obtained. A keep alive timeout property of 0.0 disables keep alives.<li>If timeout is T_IPC_TIMEOUT_DELIVERY, the delivery timeout of the connection is obtained. A delivery timeout property of 0.0 disables checking for delivery timeouts. </ul>
</td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the timeout which is set. </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a10">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a75" doxytag="SmartSockets::TipcSrv::getUniqueSubject"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* SmartSockets::TipcSrv::getUniqueSubject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the connections unique subject. <dl compact><dt><b>
Returns: </b><dd>
the unique subject name </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a44" doxytag="SmartSockets::TipcSrv::getUser"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual const char* SmartSockets::TipcSrv::getUser </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines the user name of the connected server. <dl compact><dt><b>
Returns: </b><dd>
the user information </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a41">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a26" doxytag="SmartSockets::TipcSrv::getXtSource"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual sock SmartSockets::TipcSrv::getXtSource </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets an XtAppAddInput-compatible source from a connection, which allows SmartSockets connections to be mixed with Motif or any other Xt-based widget set. Both Xt and <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a> have their own main loop functions: XtAppMainLoop for Xt and <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">mainLoop</a>() for <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a>. Since only one main loop function can be used, it is easiest to use XtAppAddInput for incorporating other sources of input into Xt's event- handling mechanism. See the SmartSockets User's Guide for more information on integrating SmartSockets with Motif/Xt. <dl compact><dt><b>
Returns: </b><dd>
source for XtAppAddInput </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a14">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a58" doxytag="SmartSockets::TipcSrv::gmdFileCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::gmdFileCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a guaranteed message delivery (GMD) area on the connection to RTserver. This is a low level method that is automatically called from <a class="el" href="classSmartSockets_1_1TipcSrv.html#a7">open</a>() if a GMD areal doesn't exist; only advanced applications that want to speed up the connection process should call this. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a46">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a59" doxytag="SmartSockets::TipcSrv::gmdFileDelete"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::gmdFileDelete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes from disk guaranteed message delivery (GMD) files for a connection. TipcConnGmdFileDelete is useful for processes that wish to completely delete any obsolete GMD information. When a process using GMD creates a connection, one of two scenarios is possible:
<p>
<ul>
<li>the process does not care about GMD information from a previous connection with the same GMD configuration and should thus call <a class="el" href="classSmartSockets_1_1TipcSrv.html#a59">gmdFileDelete</a>() to delete the old files<li>the process is recreating the connection after a network failure and should thus call <a class="el" href="classSmartSockets_1_1TipcSrv.html#a60">gmdResend</a>() to resend all previously sent messages that may have been lost when the connection was destroyed.</ul>
TipcConnGmdFileDelete should be used carefully, as deleting GMD files removes all record of old messages that were supposed to be delivered. to RTserver.
<p>
<dl compact><dt><b>
Warning: </b><dd>
Old GMD files must be removed before any messages with guaranteed delivery are sent or received on the connection. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a59">gmdFileDelete</a>() does not delete the GMD files if they are already open by this process and in use for the connection. The GMD files are opened by <a class="el" href="classSmartSockets_1_1TipcSrv.html#a58">gmdFileCreate</a>(). </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a47">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a61" doxytag="SmartSockets::TipcSrv::gmdMsgDelete"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::gmdMsgDelete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>msg</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a message from the local GMD area after a GMD failure on the connection to RTserver. This method is was intended to be used from a GMD_FAILURE connection process callback to terminate GMD for the message.
<p>
When a GMD_FAILURE message is processed by a sender RTclient, one of two scenarios is possible:<ul>
<li>the sender RTclient does not want to resend the message, and thus uses TipcSrvGmdMsgDelete and TipcSrvGmdMsgServerDelete to terminate GMD for the message<li>the sender RTclient does want to resend the message, and thus takes some kind of user-defined action to correct the problem (possibly using <a class="el" href="classSmartSockets_1_1TipcSrv.html#a65">gmdMsgStatus</a>() to poll RTserver for GMD status) and then uses TipcSrvGmdMsgResend to resend the message. </ul>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>msg</em>&nbsp;</td><td>
- message to delete </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a49">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a64" doxytag="SmartSockets::TipcSrv::gmdMsgServerDelete"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::gmdMsgServerDelete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>msg</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a message in RTserver after a GMD failure on the connection to RTserver. This method sends a GMD_DELETE message to RTserver. When RTserver routes a message for GMD, it keeps the message in memory so that it can easily and quickly resend the message to any receiving RTclient that disconnects and reconnects. This method informs RTserver to terminate GMD for the message, which allows RTserver to reclaim the memory for the message. This method is intended to be used from a GMD_FAILURE connection process callback to terminate GMD for the message.
<p>
When a GMD_FAILURE message is processed by a sender RTclient, one of two scenarios is possible:
<p>
<ul>
<li>the sender RTclient does not want to resend the message, and thus uses TipcSrvGmdMsgDelete and TipcSrvGmdMsgServerDelete to terminate GMD for the message<li>the sender RTclient does want to resend the message, and thus takes some kind of user-defined action to correct the problem (possibly using <a class="el" href="classSmartSockets_1_1TipcSrv.html#a65">gmdMsgStatus</a>() to poll RTserver for GMD status) and then uses TipcSrvGmdMsgResend to resend the message. </ul>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>msg</em>&nbsp;</td><td>
- message to delete </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a65" doxytag="SmartSockets::TipcSrv::gmdMsgStatus"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::gmdMsgStatus </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>msg</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls RTserver for GMD status of a message. This method polls for the GMD status of msg by sending a GMD_STATUS_CALL message to RTserver. RTserver responds by sending back a GMD_STATUS_RESULT message. The response should come back very quickly. The polling RTclient can use functions such as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">searchType</a>() to get the response.
<p>
When RTserver routes a message for GMD, it keeps track of which RTclients should receive the message and the status of GMD to each of these RTclients. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a65">gmdMsgStatus</a>() is intended to be used from a GMD_FAILURE connection process callback to query GMD status for the message. The GMD_STATUS_RESULT message contains four fields:<ul>
<li>an INT4 integer field containing the sequence number property of the message<li>a STR_ARRAY string array field containing the names of the RTclients that have acknowledged successful delivery of the message<li>a STR_ARRAY string array field containing the names of the RTclients where GMD has failed for the message<li>a STR_ARRAY string array field containing the names of the RTclients where delivery is still pending for the message.</ul>
If RTserver does not have an in-memory GMD record of msg, RTserver silently ignores the GMD_STATUS_CALL message and no GMD_STATUS_RESULT message is returned. This indicates that one of these has happened:<ul>
<li>RTserver has fully delivered msg<li>TipcSrvGmdMsgServerDelete was used to terminate GMD for the message<li>RTserver never routed msg</ul>
When a GMD_FAILURE message is processed by a sender RTclient, one of two scenarios is possible:<ul>
<li>the sender RTclient does not want to resend the message, and thus uses <a class="el" href="classSmartSockets_1_1TipcSrv.html#a61">gmdMsgDelete</a>() and <a class="el" href="classSmartSockets_1_1TipcSrv.html#a64">gmdMsgServerDelete</a>() to terminate GMD for the message<li>the sender RTclient does want to resend the message, and thus takes some kind of user-defined action to correct the problem (possibly using <a class="el" href="classSmartSockets_1_1TipcSrv.html#a65">gmdMsgStatus</a>() to poll RTserver for GMD status) the message. </ul>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>msg</em>&nbsp;</td><td>
- message for which the status is requested </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a60" doxytag="SmartSockets::TipcSrv::gmdResend"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::gmdResend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resends all guaranteed messages after a delivery failure on the connection to RTserver. <dl compact><dt><b>
Warning: </b><dd>
Be very careful when using this method, as it may result in severe amounts of network traffic. This method should only be called when a network error occurs, and not under any other circunstances; if used while a connection to RTserver is still alive, it could cause a storm of resent GMD messages. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a48">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a30" doxytag="SmartSockets::TipcSrv::insert"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int4&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pos</em> = T_IPC_POS_PRIORITY</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a message into the queue of the connection. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>msg</em>&nbsp;</td><td>
- message to be inserted </td></tr>
<tr><td valign=top><em>pos</em>&nbsp;</td><td>
- position at which the message to be inserted. Defaults to T_IPC_POS_PRIORITY, which inserts the message in priority order, after all other * message with equal or higher priority. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a30">insert</a>() also calls the connection's queue callbacks. </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the insertion fails </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a17">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a28" doxytag="SmartSockets::TipcSrv::keepAlive"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::keepAlive </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks if the server connection is still alive. This method performs a remote procedure call to check if the process at the other end of a connection is still alive. This explicit attempt to check the health of a connection is called a keep alive. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a28">keepAlive</a>() is normally used only by checki(), which automatically checks the connection based on the read timeout property of the connection. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a28">keepAlive</a>() can be called explicitly, though, to check the health of the connection. If the other end of the connection is alive, it receives the KEEP_ALIVE_CALL message, processes it with TipcCbConnProcessKeepAliveCall, and sends a KEEP_ALIVE_RESULT message back to this end. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a15">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a48" doxytag="SmartSockets::TipcSrv::lock"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::lock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquires exclusive access to the connection. This method locks all of the internal synchronization objects within the connection to RTserver. This insures that the calling thread in a multi-threaded process has exclusive access to the connection to RTserver. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a48">lock</a>() may be called by a thread recursively. <dl compact><dt><b>
Warning: </b><dd>
Every call to <a class="el" href="classSmartSockets_1_1TipcSrv.html#a48">lock</a>() must be balanced by a call to <a class="el" href="classSmartSockets_1_1TipcSrv.html#a49">unlock</a>(). </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the lock cannot be acquired. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a44">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="d0" doxytag="SmartSockets::TipcSrv::logAddMt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::logAddMt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IPC_MT_LOG_TYPE&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>log_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a message type to a message file logging type on the connection to RTserver. Each logging type has two options that can be used to log incoming and outgoing messages in that logging type. When the option is set (the option value should be the name of a file), then read callbacks (for incoming) or write callbacks (for outgoing) are created for all the logging type's message types in the connection to RTserver. More than one option can use the same file:<ul>
<li>The logging type T_IPC_SRV_LOG_DATA, which is for variable value message types such as TIME and NUMERIC_DATA, is controlled by the options Log_In_Data and Log_Out_Data.<li>The logging type T_IPC_SRV_LOG_STATUS, which is for RThci messages types such ALERT and POPUP, is controlled by the options Log_In_Status and Log_Out_Status.<li>The logging type T_IPC_SRV_LOG_INTERNAL, which is for all other message types such as SUBJECT_SET_SUBSCRIBE and SERVER_STOP_CALL, is controlled by the options Log_In_Internal and Log_Out_Internal. All of the standard SmartSockets message types are added automatically to one logging type.</ul>
Message types can be added to multiple logging types.
<p>
<dl compact><dt><b>
Warning: </b><dd>
The message logging methods should be called before <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a> conn is created, so they are static too. </dl><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>log_type</em>&nbsp;</td><td>
- the T_IPC_MT_LOG_TYPE value (either T_IPC_SRV_LOG_DATA, T_IPC_SRV_LOG_STATUS, or T_IPC_SRV_LOG_INTERNAL). </td></tr>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
- the message type </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d1" doxytag="SmartSockets::TipcSrv::logRemoveMt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::logRemoveMt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IPC_MT_LOG_TYPE&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>log_type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes a message type from a message file logging type on the connection to RTserver. Each logging type has two options that can be used to log incoming and outgoing messages in that logging type. When the option is set (the option value should be the name of a file), then read callbacks (for incoming) or write callbacks (for outgoing) are created for all the logging type's message types in the connection to RTserver. More than one option can use the same file:<ul>
<li>The logging type T_IPC_SRV_LOG_DATA, which is for variable value message types such as TIME and NUMERIC_DATA, is controlled by the options Log_In_Data and Log_Out_Data.<li>The logging type T_IPC_SRV_LOG_STATUS, which is for RThci messages types such ALERT and POPUP, is controlled by the options Log_In_Status and Log_Out_Status.<li>The logging type T_IPC_SRV_LOG_INTERNAL, which is for all other message types such as SUBJECT_SET_SUBSCRIBE and SERVER_STOP_CALL, is controlled by the options Log_In_Internal and Log_Out_Internal. All of the standard SmartSockets message types are added automatically to one logging type.</ul>
Message types can be added to multiple logging types. <dl compact><dt><b>
Warning: </b><dd>
The message logging methods should be called before <a class="el" href="classSmartSockets_1_1TipcSrv.html">TipcSrv</a> conn is created, so they are static too. </dl><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>log_type</em>&nbsp;</td><td>
- the T_IPC_MT_LOG_TYPE value (either T_IPC_SRV_LOG_DATA, T_IPC_SRV_LOG_STATUS, or T_IPC_SRV_LOG_INTERNAL). </td></tr>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
- the message type </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a29" doxytag="SmartSockets::TipcSrv::mainLoop"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool SmartSockets::TipcSrv::mainLoop </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">real8&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>timeout</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads and processes messages on a connection. This method is a convenience function that keeps calling TipcConnMsgNext with the time remaining from timeout until <a class="el" href="classSmartSockets_1_1TipcSrv.html#a31">next</a>() throws an exception or times out. For each <a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> that <a class="el" href="classSmartSockets_1_1TipcSrv.html#a29">mainLoop</a>() gets, it processes the message with <a class="el" href="classSmartSockets_1_1TipcSrv.html#a33">process</a>() and then destroys the message. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
- number of seconds to look for messages and process them. Use 0.0 for timeout to process one message. Use T_TIMEOUT_DRAIN to poll the connection and catch up on all pending messages that have accumulated without reading any new ones. Use T_TIMEOUT_FOREVER for timeout to read and process messages indefinitely. </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a16">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a31" doxytag="SmartSockets::TipcSrv::next"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::next </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timeout</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the next message from the connection. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
- number of seconds to look for a message. Use 0.0 for timeout to poll the connection once and get the next message available. Use the default of T_TIMEOUT_FOREVER for timeout to wait indefinitelly for a new message. </td></tr>
<tr><td valign=top><em>msg</em>&nbsp;</td><td>
- place holder object for return value. </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs, or the timeout has expired. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a20">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a32" doxytag="SmartSockets::TipcSrv::nextEx"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool SmartSockets::TipcSrv::nextEx </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timeout</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the next message from the connection. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
- number of seconds to look for a message. Use 0.0 for timeout to poll the connection once and get the next message available. </td></tr>
<tr><td valign=top><em>msg</em>&nbsp;</td><td>
- place holder object for return value. </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
false if the timeout is expired, true otherwise. </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a21">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="SmartSockets::TipcSrv::open"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::open </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IPC_SRV_CONN_STATUS&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>create_status</em> = T_IPC_SRV_CONN_FULL          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Opens a connection. A connection can be openned as a full connection or as a warm connection. A full connection allows the application to send or receive SmartSockets <a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> objects. A warm connection allows clients to buffer <a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> objects in memory before a full connection is established. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>create_status</em>&nbsp;</td><td>
- determines whether to create a warm connection (use T_IPC_SRV_CONN_WARM) or a full connection (use T_IPC_SRV_CONN_FULL). The default is T_IPC_SRV_CONN_FULL </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a79" doxytag="SmartSockets::TipcSrv::openCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1ConnectionCallBack.html">ConnectionCallBack</a>&gt;* SmartSockets::TipcSrv::openCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1ConnectionCallBack.html">ConnectionCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an open connection callback. Open callbacks are called when this object creates a warm or full connection to RTserver.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
a connection callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
optional argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows how to create an open callback that is invoked once when the server connection is opened; the connection is then deactivated and the connection is opened and closed again. <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;

 <font class="keyword">class </font>MyConnCb : <font class="keyword">public</font> ConnectionCallBack
 {
   <font class="keyword">public</font>:
     <font class="keyword">virtual</font> <font class="keywordtype">void</font> onConnection (
        CallBack &lt; ConnectionCallBack &gt; * callBack,
        TipcSrv &amp; connection,
        ConnStatus oldConnStatus,
        ConnStatus newConnStatus)
     {
       <font class="keyword">const</font> <font class="keywordtype">char</font>* arg = (<font class="keyword">const</font> <font class="keywordtype">char</font>*) callBack-&gt;getArgument();
       cout &lt;&lt; <font class="stringliteral">" in conn CB open() - "</font> &lt;&lt; arg &lt;&lt; endl;
     }
 };
 <font class="keywordtype">int</font> main ()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/foo"</font>,<font class="stringliteral">"tcp:_node"</font>);
     MyConnCb* myCb = <font class="keyword">new</font> MyConnCb();
     CallBack&lt;ConnectionCallBack&gt;* cb = srv.openCbCreate(myCb,<font class="stringliteral">"s1"</font>);
     srv.open();

     srv.close();

     <font class="comment">// This should disable the callback.</font>
     cb-&gt;destroy();
     srv.open();
     srv.close();
     <font class="keyword">delete</font> myCb;
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> Here is the output for the code: <div class="fragment"><pre>

       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;
        in conn CB open() - s1
       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;

       </pre></div> </dl>    </td>
  </tr>
</table>
<a name="e1" doxytag="SmartSockets::TipcSrv::openCbDelegator"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void T_ENTRY1 SmartSockets::TipcSrv::openCbDelegator </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IPC_SRV&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>connection</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_IPC_SRV_OPEN_CB_DATA&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_CB_ARG&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static, protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delegator method for open connection callbacks. Will be called when the callback is triggered and will in turn call the callback's handler method.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>connection</em>&nbsp;</td><td>
the connection on which the callback was triggered </td></tr>
<tr><td valign=top><em>data</em>&nbsp;</td><td>
the connection callback data (contains the message to which connection status information for which the callback applies) </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
the callback object </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a3" doxytag="SmartSockets::TipcSrv::operator T_IPC_CONN"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SmartSockets::TipcSrv::operator T_IPC_CONN </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the C style T_IPC_CONN handle to the connection. Note that a valid T_IPC_CONN is only returned if a connection has been opened. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a4" doxytag="SmartSockets::TipcSrv::operator T_IPC_SRV"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SmartSockets::TipcSrv::operator T_IPC_SRV </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the C style T_IPC_SRV handle to the connection. <dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a41" doxytag="SmartSockets::TipcSrv::print"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::print </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_OUT_FUNC&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>func</em> = (T_OUT_FUNC) TutOut          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prints information about the connection to standard out. The output can also be redirected if the parameter func is passed <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>func</em>&nbsp;</td><td>
- the method used to print the connection information. This method should match the following signature: void T_ENTRY &lt;func&gt; (char*, ...); </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a28">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a33" doxytag="SmartSockets::TipcSrv::process"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::process </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>msg</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Processes a message in a connection by calling the process, subject or default callbacks. The default callbacks are only called if there are no non-global process callbacks for the type of message being processed. Processing a message with two levels of callbacks allows for more flexibility. For example, RTserver creates a few process callbacks for the message types it needs to process locally (such as SUBJECT_SET_SUBSCRIBE), but the majority of the message types (such as NUMERIC_DATA) are simply routed to their destination by a default callback. Any message can be processed by <a class="el" href="classSmartSockets_1_1TipcSrv.html#a33">process</a>(), not just messages read from a connection. For example, a generic message file data source could be implemented using the extractor operator to read messages from a file then the messages created can be processed by calling <a class="el" href="classSmartSockets_1_1TipcSrv.html#a33">process</a>(). <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>msg</em>&nbsp;</td><td>
- message to be processed </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a18">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a85" doxytag="SmartSockets::TipcSrv::processCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a>&gt;* SmartSockets::TipcSrv::processCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a process callback that is triggered after a call to <a class="el" href="classSmartSockets_1_1TipcSrv.html#a33">process</a>(). Process callback objects are triggered by a call to <a class="el" href="classSmartSockets_1_1TipcSrv.html#a33">process</a>() to perform the normal processing of a message, such as storing numeric data values and then acting on the variables. A process callback is usually created for a specific message type and connection. If the message type is null (<a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> nullMt((T_IPC_MT)NULL);), then a global process callback is created for all message types on that connection.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
the message type for the callback </td></tr>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
a messagen callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcSrv.html#a84">defaultCbCreate</a>() for an example that shows this method being used. </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a34">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a78" doxytag="SmartSockets::TipcSrv::queueCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1MessageQueueCallBack.html">MessageQueueCallBack</a>&gt;* SmartSockets::TipcSrv::queueCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1MessageQueueCallBack.html">MessageQueueCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a message queue callback. Queue callbacks are called when a message is inserted into or deleted from a connection's queue of incoming messages. Queue callbacks are useful for watching the messages that have been read in by a connection, but not yet processed. There is some overlap between read callbacks and queue callbacks.
<p>
A queue callback is usually created for a specific message type and connection. If the message type is null (e.g. <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> nullMt((T_IPC_MT)NULL), then a global queue callback is created for all message types on that connection.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
the message type for the callback </td></tr>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
a message queue callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows a queue callback that gets triggered for incoming and outgoing messages: <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;

 <font class="keyword">class </font>MyQueueCb : <font class="keyword">public</font> MessageQueueCallBack
 {
   <font class="keyword">public</font>:
     <font class="keywordtype">void</font> onMessage (CallBack &lt;MessageQueueCallBack&gt; * callBack,
                      TipcMsg &amp; message,
                      TipcConn &amp; connection,
                      uint4 queuePos,
                      <font class="keywordtype">bool</font> is_insert)
     {
       <font class="keyword">const</font> <font class="keywordtype">char</font>* direction = is_insert? <font class="stringliteral">"inserted"</font>: <font class="stringliteral">"dequeued"</font>;
       cout &lt;&lt; <font class="stringliteral">"in onMessage(); direction = "</font> &lt;&lt; direction &lt;&lt; endl;
     }
 };
 <font class="keywordtype">int</font> main ()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/foo"</font>,<font class="stringliteral">"tcp:_node"</font>);
     MyQueueCb* myCb = <font class="keyword">new</font> MyQueueCb();
     srv.open();
     CallBack&lt;MessageQueueCallBack&gt;* cb = srv.queueCbCreate(
                                  TipcMt::lookup(T_MT_INFO),myCb,<font class="stringliteral">"s1"</font>);

     TipcMsg msg(T_MT_INFO,<font class="stringliteral">"/foo"</font>);
     msg &lt;&lt; <font class="stringliteral">"test"</font>;
     srv.send(msg);
     srv.mainLoop(10.0);
     <font class="comment">// This should disable the callback.</font>
     cb-&gt;destroy();

     <font class="keyword">delete</font> myCb;
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> Here's the output of this code: <div class="fragment"><pre>
       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;
       in onMessage(); direction = inserted
       in onMessage(); direction = dequeued
       </pre></div> </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a29">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a36" doxytag="SmartSockets::TipcSrv::read"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">real8&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>timeout</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads all available data from the connection to RTserver and queues messages in priority order. If the connection's auto flush size is not T_IPC_NO_AUTO_FLUSH, then <a class="el" href="classSmartSockets_1_1TipcSrv.html#a36">read</a>() first calls <a class="el" href="classSmartSockets_1_1TipcSrv.html#a9">flush</a>() to flush the connection's write buffer (so that any responses to the outgoing data are available sooner). <a class="el" href="classSmartSockets_1_1TipcSrv.html#a36">read</a>() then reads data (in the form of message packets) from a connection's socket and calls the connection decode callbacks. If necessary, the integers and strings in the message header are converted to the formats used by the receiving process. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a36">read</a>() then converts the message packets into messages, and calls the connection's read callbacks. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a36">read</a>() returns as soon as at least one message is read, so that high-data-rate applications do not sit forever reading data. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
- timeout value, until which the read operation can be performed. Use the default of T_TIMEOUT_FOREVER for timeout to wait indefinitelly for a new message. </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 thrown if an error occurs. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a19">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a86" doxytag="SmartSockets::TipcSrv::readCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a>&gt;* SmartSockets::TipcSrv::readCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a read callback. Read callback objects are called when a new message is received from the connection's socket, which occurs whenever <a class="el" href="classSmartSockets_1_1TipcSrv.html#a36">read</a>() is called. Connection read callbacks are useful for message file logging and preprocessing of messages before the normal processing with <a class="el" href="classSmartSockets_1_1TipcSrv.html#a33">process</a>().
<p>
A read callback is usually created for a specific message type and connection. If the message type is null (e.g. <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> nullMt((T_IPC_MT) NULL) ), then a global read callback is created for all message types on that connection.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
the message type for the callback </td></tr>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
a messagen callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows an read callback that gets triggered for all outgoing messages: <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;

 <font class="keyword">class </font>MyCb : <font class="keyword">public</font> MessageCallBack
 {
   <font class="keyword">public</font>:
     <font class="keywordtype">void</font> onMessage (CallBack &lt;MessageCallBack&gt; * cb,
                      TipcMsg &amp; message,
                      TipcConn &amp; connection)
     {
       cout &lt;&lt; <font class="stringliteral">"in onMessage(); - (read Cb) "</font>
            &lt;&lt; message.getType().getName() &lt;&lt; endl;
     }
 };
 <font class="keywordtype">int</font> main ()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/foo"</font>,<font class="stringliteral">"tcp:_node"</font>);
     MyCb* myCb = <font class="keyword">new</font> MyCb();
     srv.open();
     TipcMt mt((T_IPC_MT)NULL);
     CallBack&lt;MessageCallBack&gt;* cb = srv.readCbCreate(mt, myCb);

     TipcMsg msg(T_MT_INFO,<font class="stringliteral">"/foo"</font>);
     msg &lt;&lt; <font class="stringliteral">"test"</font>;
     srv.send(msg);
     srv.mainLoop(10.0);
     <font class="comment">// This should disable the callback.</font>
     cb-&gt;destroy();

     <font class="keyword">delete</font> myCb;
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> Here's the output of this code: <div class="fragment"><pre>
       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;
       in onMessage(); - (read Cb) info

       </pre></div> </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a35">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a34" doxytag="SmartSockets::TipcSrv::search"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::search </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1TipcConnSearchSelector.html">TipcConnSearchSelector</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>selObj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timeout</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Searches the message queue of the connection for a specific message. The connection has a priority queue of incoming messages. This method traverses the messages in this internal priority queue calling the <a class="el" href="classSmartSockets_1_1TipcConnSearchSelector.html">TipcConnSearchSelector</a> object's onSearch() method until either <a class="el" href="classSmartSockets_1_1TipcConnSearchSelector.html#a4">TipcConnSearchSelector::onSearch</a>() returns true, or the timeout period expires. If <a class="el" href="classSmartSockets_1_1TipcConnSearchSelector.html#a4">TipcConnSearchSelector::onSearch</a>() returns true, the message is removed from the queue and put into the msg parameter. If the end of the queue is reached, <a class="el" href="classSmartSockets_1_1TipcSrv.html#a36">read</a>() is called with the remaining timeout. If any new messages arrive, the queue is traversed again. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>msg</em>&nbsp;</td><td>
place holder object for return value. </td></tr>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
- the number of seconds this method will block waiting for the selector object selObj to select a <a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a>. Use the default of T_TIMEOUT_FOREVER for timeout to wait indefinitelly for a new message. </td></tr>
<tr><td valign=top><em>selObj</em>&nbsp;</td><td>
- the selector object with user-defined criteria for finding a message. See <a class="el" href="classSmartSockets_1_1TipcConnSearchSelector.html">TipcConnSearchSelector</a> for more details. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the message found as a result of the search via the argument msg. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs, or the timeout is reached. </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows a selector that searches for an info message type with the second letter in the first field = to r: <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">class </font>MyTrav: <font class="keyword">public</font> TipcConnSearchSelector
 {
   <font class="keyword">public</font>:
     <font class="keywordtype">bool</font> onSearch(<font class="keyword">const</font> TipcConn &amp; conn, <font class="keyword">const</font> TipcMsg&amp; msg) <font class="keywordflow">throw</font> ()
     {
       <font class="keywordflow">try</font>
       {
         <font class="keywordflow">if</font> (msg.getTypeNum() == T_MT_INFO)
         {
           <font class="keyword">const</font> <font class="keywordtype">char</font>* data = msg.nextString();
           <font class="keywordflow">if</font> (strlen(data) &gt;= 2)
           {
             <font class="keywordflow">if</font> (data[1] == <font class="charliteral">'r'</font>)
             {
               <font class="keywordflow">return</font> <font class="keyword">true</font>;
             }
           }
         }
       }
       <font class="keywordflow">catch</font> (...)
       {
       }
       <font class="keywordflow">return</font> <font class="keyword">false</font>;
     }
 };
 <font class="keywordtype">int</font> main ()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv ((<font class="keyword">const</font> <font class="keywordtype">char</font>*) 0, (<font class="keyword">const</font> <font class="keywordtype">char</font>*) 0);
     srv.open();
     srv.setSubscribe(<font class="stringliteral">"/foo"</font>);
     MyTrav* trav = <font class="keyword">new</font> MyTrav();
     TipcMsg msg;
     srv.search(msg,trav);
     msg.print();
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a22">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a35" doxytag="SmartSockets::TipcSrv::searchType"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::searchType </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timeout</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Searches the message queue of the connection for a message with a specific type. This is a convenience method that uses the same technique as <a class="el" href="classSmartSockets_1_1TipcSrv.html#a34">search</a>() with a specific selector object that looks for messages of a particular type. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>msg</em>&nbsp;</td><td>
place holder object for return value. </td></tr>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
- <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> object; message type </td></tr>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
- the timeout value until which the search can be performed Use the default of T_TIMEOUT_FOREVER for timeout to wait indefinitelly for a new message. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the message found as a result of the search via the argument msg. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a23">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a37" doxytag="SmartSockets::TipcSrv::send"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::send </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>check_server_msg_send</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends a <a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> through the connection. If check_server_msg_send is set to true and the option Server_Msg_Send is false, then <a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a>() does not send the message, but returns immediately. Otherwise <a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a>() first temporarily sets the sender of the message (using the value of the option Unique_Subject), then temporarily prepends the value of the option Default_Subject_Prefix to the message sender and destination if they do not start with slash (/), and calls the appropriate write callbacks.
<p>
If the message has a delivery mode of either T_IPC_DELIVERY_SOME or T_IPC_DELIVERY_ALL, then TipcConnMsgSend performs some extra steps for guaranteed message delivery. If the connection does not have a GMD area open, then <a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a>() calls <a class="el" href="classSmartSockets_1_1TipcSrv.html#a58">gmdFileCreate</a>() to create the necessary GMD area. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a>() increments an internal per-connection sequence number, sets the sequence number of the message to the incremented value, and then saves a copy of the message to the GMD area so that the message can be easily resent. With file-based GMD, recovery can take place even if this process crashes and has to be restarted. If the message delivery timeout property is not set, then the connection delivery timeout value is used for GMD.
<p>
<a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a>() then converts the message into a message packet (checking the message header string encode property to see if header strings should be encoded as integers to save space), executes the connection encode callbacks, and appends the message packet to the connection's write buffer. TipcConnMsgSend then calls TipcConnFlush if the number of bytes in the connection's write buffer is greater than the connection's auto flush size. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>msg</em>&nbsp;</td><td>
- message to sent it through the RTserver </td></tr>
<tr><td valign=top><em>check_server_msg_send</em>&nbsp;</td><td>
- flag for check server message send </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcConnException.html">TipcConnException</a></em>&nbsp;</td><td>
, <a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a> if an error occurs. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a24">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a38" doxytag="SmartSockets::TipcSrv::sendRpc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::sendRpc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>reply_msg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>call_msg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timeout</em> = T_TIMEOUT_FOREVER</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes a remote procedure call (RPC) with <a class="el" href="classSmartSockets_1_1TipcMsg.html">TipcMsg</a> objects. One message is sent as the RPC call from the caller end of the connection, and another message is sent back as the RPC result to the caller. The callee end of the connection must be prepared to receive the call message and send back the result message. The relationship between the call and result message is that the message type number of the result message is always one greater than the message type number of the call message.
<p>
<a class="el" href="classSmartSockets_1_1TipcSrv.html#a38">sendRpc</a>() sends the message with <a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a>(), flushes all pending outgoing data with <a class="el" href="classSmartSockets_1_1TipcSrv.html#a9">flush</a>(), and then waits for the result with <a class="el" href="classSmartSockets_1_1TipcSrv.html#a35">searchType</a>(). <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>reply_msg</em>&nbsp;</td><td>
- message received as a result of call_msg. </td></tr>
<tr><td valign=top><em>call_msg</em>&nbsp;</td><td>
- message to be sent through RPC. </td></tr>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
- number of seconds to wait for a reply message. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the reply message via the reply_msg argument. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows the sender side of an RPC call: <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;
 <font class="keywordtype">int</font> main()
 {
   <font class="keywordflow">try</font>
   {
     <font class="comment">// create message types with the numbers differing by one; whenever</font>
     <font class="comment">// using sendRpc, the request type number has to be one less than</font>
     <font class="comment">// the reply.</font>
     TipcMt reqMt = TipcMt::create(<font class="stringliteral">"requestMt"</font>,444,<font class="stringliteral">""</font>);
     TipcMt replyMt = TipcMt::create(<font class="stringliteral">"replyMt"</font>,445,<font class="stringliteral">"verbose"</font>);

     <font class="comment">// create the reply and request messages.</font>
     TipcMsg replyMsg(replyMt);
     TipcMsg requestMsg(reqMt);

     <font class="comment">// set the destination of the request message to a subject that</font>
     <font class="comment">// another connection will listen.</font>
     requestMsg.setDest(<font class="stringliteral">"/requests"</font>);

     <font class="comment">// Create a server connection</font>
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/uniqueSubj1"</font>, <font class="stringliteral">"tcp:_node"</font>);
     srv.open();

     <font class="comment">// call this method with a timeout forever.</font>
     srv.sendRpc(replyMsg,requestMsg);

     <font class="comment">// print the contents of the message to standard out.</font>
     replyMsg.print();
   }
   <font class="keywordflow">catch</font> (Exception&amp; e)
   {
     cout &lt;&lt; <font class="stringliteral">"exception caught; error = "</font> &lt;&lt; e.what() &lt;&lt; endl;
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a25">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a11" doxytag="SmartSockets::TipcSrv::setAutoFlushSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::setAutoFlushSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int4&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>auto_flush_size</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the auto_flush_size of a connection to the RTserver. The auto flush size is used to control how much outgoing data (in bytes) are buffered before being automatically flushed to RTserver. The default for the auto flush size is 8192 bytes. If set to T_IPC_NO_AUTO_FLUSH, data will never be flushed. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>auto_flush_size</em>&nbsp;</td><td>
- the number of bytes after which data will be sent down the wire. </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a77" doxytag="SmartSockets::TipcSrv::setCredentials"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::setCredentials </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int4&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>auth_policy_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>auth_data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int4&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>auth_data_len</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the connection's credentials. This method allows any credential mechanisms (e.g. Kerberos, certificates, user name and password, etc.) to be used to authenticate a client application before it joins an RTserver cloud. The data used here will be passed to the appropriate Security manager in place, and it's up to that process to grant or deny access to the RTserver cloud. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>auth_policy_id</em>&nbsp;</td><td>
- authorization policy Id </td></tr>
<tr><td valign=top><em>auth_data</em>&nbsp;</td><td>
- authorization data </td></tr>
<tr><td valign=top><em>auth_data_len</em>&nbsp;</td><td>
- authorization data length </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a72" doxytag="SmartSockets::TipcSrv::setDefaultSubjectPrefix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::setDefaultSubjectPrefix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>default_subject_prefix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the connections default subject prefix. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>default_subject_prefix</em>&nbsp;</td><td>
- default subject prefix to be set to </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a63" doxytag="SmartSockets::TipcSrv::setGmdMaxSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::setGmdMaxSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint4&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>gmd_max_size</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the GMD area's maximum size of the connection to RTserver. A GMD area holds guaranteed message delivery information for both incoming and outgoing messages. There are two types of guaranteed message delivery: file-based GMD and memory-only GMD.
<p>
For file-based GMD this limit is the maximum file size, and for memory-only GMD this limit is the maximum amount of memory allowed. The default GMD area maximum size is 0, which means that no GMD area maximum size limit checking is performed. The connection GMD area maximum size and the connection delivery timeout can be used to constrain the amount of system resources used for GMD by space and by time.
<p>
If the connection GMD area maximum size is exceeded, then no further messages can be sent with guaranteed delivery (<a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a>() throws an exception with the SmartSockets error number to set to T_ERR_VAL_TOO_LARGE) until some unacknowledged previously sent messages are acknowledged.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>gmd_max_size</em>&nbsp;</td><td>
- value to be set for the maximum GMD area </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a67" doxytag="SmartSockets::TipcSrv::setProject"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::setProject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>project</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the connections project. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>project</em>&nbsp;</td><td>
- project name to be set </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a69" doxytag="SmartSockets::TipcSrv::setServerNames"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::setServerNames </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>server_names</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the connections server names. This may be a comma delimited list of server names. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>server_names</em>&nbsp;</td><td>
- server names comma delimited list of server names </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a70" doxytag="SmartSockets::TipcSrv::setServerNamesList"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::setServerNamesList </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_STR_LIST&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>server_names_list</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the connections server names. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>server_names</em>&nbsp;</td><td>
- the connections server names </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a52" doxytag="SmartSockets::TipcSrv::setSubscribe"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::setSubscribe </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>subject</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>recv_status</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Starts or stops subscribing to a subject. This method sets whether or not this object is subscribing to a subject. The subscribe status controls whether or not the connection receives messages published (sent) to that subject. If the subscribe status of subject is true, then the connection receives messages with subject as their destination that are sent to RTserver. To determine if an connection is subscribing to a subject, use <a class="el" href="classSmartSockets_1_1TipcSrv.html#a51">getSubscribe</a>(). <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>subject</em>&nbsp;</td><td>
- subject name </td></tr>
<tr><td valign=top><em>recv_status</em>&nbsp;</td><td>
- the receive status flag (true to start subscribing, false to stop subscribing). </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a76" doxytag="SmartSockets::TipcSrv::setSubscribeCache"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::setSubscribeCache </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>subj_name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>status</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int4&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Subscribes to a subject obtaining the last cached value from SmartCache. See SmartCache's documentation for more information on how to use this method. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>subj_name</em>&nbsp;</td><td>
- subject name </td></tr>
<tr><td valign=top><em>status</em>&nbsp;</td><td>
- True To Subscribe or False To Unsubscribe </td></tr>
<tr><td valign=top><em>flags</em>&nbsp;</td><td>
- This field is used to determine the caching behaviour:<ul>
<li>use T_SUBJ_FLAG_SC_LAST_VALUE for last value caching functionality.<li>use T_SUBJ_FLAG_SC_INITIAL_LOAD for force initial load functionality. This mode is used if the value retrieved from the cache is a full refresh of data rather than an incremental update. When a client initially subscribes to a subject, the first message to be received for the particular subject is the reply message from the cache. Any messages published to the subject in the interim will be forwarded to the subscriber after the reply message. The subscription will behave normally from that point onwards.<li>use T_SUBJ_FLAG_SC_LATEST_MSG to get the latest message in the subject. In this mode, the client will subscribe to the subject and will then request the last value from the SmartCache utility for that subject. If the client receives a message on this subject before the SmartCache reply message, the SmartCache reply message will be ignored and not passed on to the client. </ul>
</td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a56" doxytag="SmartSockets::TipcSrv::setSubscribeLb"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::setSubscribeLb </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>subject</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>subject_status</em> = true, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>lb_status</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Starts or stops subscribing to a subject, with or without load balancing. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>subject</em>&nbsp;</td><td>
- subject name </td></tr>
<tr><td valign=top><em>subject_status</em>&nbsp;</td><td>
- status of the subject </td></tr>
<tr><td valign=top><em>lb_status</em>&nbsp;</td><td>
- boolean value of the load balancing status </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a54" doxytag="SmartSockets::TipcSrv::setSubscribeStd"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::setSubscribeStd </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>subscribe_status</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Starts or stops subscribing to all standard subjects. This method sets the subscribe status of the standard subjects by calling <a class="el" href="classSmartSockets_1_1TipcSrv.html#a52">setSubscribe</a>() for each standard subject. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a52">setSubscribe</a>() is often used to subscribe to subjects listed in a command file (e.g. if a command file has the following: setopt subjects "/foo", "/bar"). The following are standard subjects:<ul>
<li>subjects listed in the option Subjects<li>_&lt;node&gt; - the node-specific subject, such as _workstation1<li>_all - common subject for all RTclients As each standard subject subscribe status is changed, <a class="el" href="classSmartSockets_1_1TipcSrv.html#a52">setSubscribe</a>() prints out an informational message to standard out. This method also flushes the retrieval messages with <a class="el" href="classSmartSockets_1_1TipcSrv.html#a9">flush</a>() when it is done. </ul>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>subscribe_status</em>&nbsp;</td><td>
- flag set to start or stop subscribing throw <a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a> </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a23" doxytag="SmartSockets::TipcSrv::setTimeout"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::setTimeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IPC_TIMEOUT&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timeout</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a timeout property from the connection to RTserver. The timeout properties control how often (in seconds) the connection to RTserver is checked for possible network failures. The timeout properties of the connection to RTserver are also available in the options Server_Read_Timeout, Server_Write_Timeout, Server_Keep_Alive_Timeout, and Server_Delivery_Timeout. For the connection to RTserver, the default read timeout is 30.0 seconds, the default write timeout is 30.0 seconds, the default keep alive timeout is 15.0 seconds, and the default delivery timeout is 30.0 seconds. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
Determines the type of timeout to retrieve:<ul>
<li>If timeout is T_IPC_TIMEOUT_READ, the read timeout of the connection is obtained. <a class="el" href="classSmartSockets_1_1TipcSrv.html#a8">check</a>() uses the read timeout to control how often data is expected to be available for reading on the connection. A read timeout property of 0.0 disables checking for read timeouts.<li>If timeout is T_IPC_TIMEOUT_WRITE, the write timeout of the connection is obtained. A write timeout property of 0.0 disables checking for write timeouts.<li>If timeout is T_IPC_TIMEOUT_KEEP_ALIVE, the keep alive timeout of the connection is obtained. A keep alive timeout property of 0.0 disables keep alives.<li>If timeout is T_IPC_TIMEOUT_DELIVERY, the delivery timeout of the connection is obtained. A delivery timeout property of 0.0 disables checking for delivery timeouts. </ul>
</td></tr>
</table>
</dl><dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>value</em>&nbsp;</td><td>
the number of seconds to be set for the specific timeout. </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the timeout which is set. </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a74" doxytag="SmartSockets::TipcSrv::setUniqueSubject"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::setUniqueSubject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>unique_subject</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the connections unique subject. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>unique_subject</em>&nbsp;</td><td>
- the unique subject name </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a27" doxytag="SmartSockets::TipcSrv::setUsernamePassword"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::setUsernamePassword </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>username</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>password</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the username and password for the RTclient when connecting to an RTserver with the Basic Security Driver installed. The password is immediately encrypted and is never sent in plain text to the RTserver. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>username</em>&nbsp;</td><td>
- the username to use for authentication and authorization </td></tr>
<tr><td valign=top><em>password</em>&nbsp;</td><td>
- the password to use for authentication </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a88" doxytag="SmartSockets::TipcSrv::subjectCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a>&gt;* SmartSockets::TipcSrv::subjectCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>subject</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a subject callback. Subject callback objects are called by a call to <a class="el" href="classSmartSockets_1_1TipcSrv.html#a33">process</a>() to process a message when it is received by the subject. If subject is null, then func is called for all messages of type mt received by this connection. If mt is null, then the <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> object is called for every type of message received by subj. If both subject and mt are null (<a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> nullMt((T_IPC_MT)NULL);), the <a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> object is called for every message received by this connection.
<p>
Subject wildcards (* or ...) are supported.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>subject</em>&nbsp;</td><td>
the message subject for the callback </td></tr>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
the message type for the callback </td></tr>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
a messagen callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcSrv.html#a84">defaultCbCreate</a>() for an example that shows this method being used. </dl>    </td>
  </tr>
</table>
<a name="e0" doxytag="SmartSockets::TipcSrv::subjectCbDelegator"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void T_ENTRY1 SmartSockets::TipcSrv::subjectCbDelegator </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_IPC_CONN&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>connection</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_IPC_SRV_SUBJECT_CB_DATA&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_CB_ARG&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static, protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delegator method for subject callbacks. Will be called when the callback is triggered and will in turn call the callback's handler method.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>connection</em>&nbsp;</td><td>
the connection on which the callback was triggered </td></tr>
<tr><td valign=top><em>data</em>&nbsp;</td><td>
the subject callback data (contains the message to which the callback applies)</td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
the callback object </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a66" doxytag="SmartSockets::TipcSrv::subjectGmdInit"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::subjectGmdInit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>subject</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes GMD accounting in RTserver for a subject to which messages will be published. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>subject</em>&nbsp;</td><td>
- subject name </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a57" doxytag="SmartSockets::TipcSrv::subjectLbInit"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::subjectLbInit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>subject</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes load balancing accounting in RTserver for a subject to which messages will be published. When the RTserver connected to the publishing connection routes a message for load balancing, it keeps track of which connection should receive the message. If this RTserver is not already tracking load balancing for subject when the first published message arrives from a connection, the RTserver must start a monitoring-like watch mechanism between the RTservers of all subscribing connections. This increases the scalability of load balancing because only the relevant RTservers dynamically exchange load balancing information. The load balancing accounting continues until no messages have been published with GMD or load balancing for an interval specified by the Gmd_Publish_Timeout option. The default for Gmd_Publish_Timeout is 300 seconds. The starting of this load balancing accounting is very fast but not instantaneous. TipcSrvSubjectLbInit is intended to be used by advanced publish- subscribe applications that wish to ensure that RTserver is primed and immediately ready for load balancing publish-subscribe routing. TipcSrvSubjectLbInit is usually only used at initialization, but it can be called at any time by advanced applications which wish to initialize load balancing publishing accounting. The use of TipcSrvSubjectLbInit is strictly optional for load balancing publishing; if it is not called the load balancing setup occurs when the first GMD or load balancing message is published to subject. If RTserver is already tracking load balancing for subject, RTserver immediately returns a GMD_INIT_RESULT message. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>subject</em>&nbsp;</td><td>
- subject name </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a12" doxytag="SmartSockets::TipcSrv::trafficGetBytesRecv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int4 SmartSockets::TipcSrv::trafficGetBytesRecv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the total number of bytes received on a connection.<br>

<p>
<dl compact><dt><b>
Returns: </b><dd>
the total number of bytes received on a connection. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails.</td></tr>
</table>
</dl><dl compact><dt><b>
Note: </b><dd>
The result is truncated to 31 bits, and may contain an incorrect sign bit on some older clients. New clients should use trafficGetBytesRecv8. </dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcSrv.html#a13">trafficGetBytesRecv8</a>. </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a55">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a13" doxytag="SmartSockets::TipcSrv::trafficGetBytesRecv8"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int8 SmartSockets::TipcSrv::trafficGetBytesRecv8 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the total number of bytes received on a connection.
<p>
<dl compact><dt><b>
Returns: </b><dd>
the total number of bytes received on a connection. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a56">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a14" doxytag="SmartSockets::TipcSrv::trafficGetBytesSent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int4 SmartSockets::TipcSrv::trafficGetBytesSent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the total number of bytes written to the write buffer on a connection. This number usually is the same as the total number of bytes actually sent on the connection, but sometimes the retrieved number is larger than the number of bytes sent when the write buffer is not frequently flushed.
<p>
<dl compact><dt><b>
Returns: </b><dd>
the total number of bytes written to the write buffer on a connection. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails.</td></tr>
</table>
</dl><dl compact><dt><b>
Note: </b><dd>
The result is truncated to 31 bits, and may contain an incorrect sign bit on some older clients. New clients should use trafficGetBytesSent8. </dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcSrv.html#a15">trafficGetBytesSent8</a>. </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a57">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a15" doxytag="SmartSockets::TipcSrv::trafficGetBytesSent8"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int8 SmartSockets::TipcSrv::trafficGetBytesSent8 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the total number of bytes written to the write buffer on a connection. This number usually is the same as the total number of bytes actually sent on the connection, but sometimes the retrieved number is larger than the number of bytes sent when the write buffer is not frequently flushed.
<p>
<dl compact><dt><b>
Returns: </b><dd>
the total number of bytes written to the write buffer on a connection. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a58">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a16" doxytag="SmartSockets::TipcSrv::trafficGetMsgsRecv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int4 SmartSockets::TipcSrv::trafficGetMsgsRecv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the total number of messages received on a connection.
<p>
<dl compact><dt><b>
Returns: </b><dd>
the total number of messages received on a connection. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails.</td></tr>
</table>
</dl><dl compact><dt><b>
Note: </b><dd>
The result is truncated to 31 bits, and may contain an incorrect sign bit on some older clients. New clients should use trafficGetMsgsRecv8. </dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcSrv.html#a17">trafficGetMsgsRecv8</a>. </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a59">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a17" doxytag="SmartSockets::TipcSrv::trafficGetMsgsRecv8"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int8 SmartSockets::TipcSrv::trafficGetMsgsRecv8 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the total number of messages received on a connection.
<p>
<dl compact><dt><b>
Returns: </b><dd>
the total number of messages received on a connection. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a60">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a18" doxytag="SmartSockets::TipcSrv::trafficGetMsgsSent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int4 SmartSockets::TipcSrv::trafficGetMsgsSent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the total number of messages written to the write buffer on a connection. This number usually is the same as the total number of messages actually sent on the connection, but sometimes the retrieved number is larger than the number of messages sent when the write buffer is not frequently flushed.
<p>
<dl compact><dt><b>
Returns: </b><dd>
the total number of messages written to the write buffer on a connection. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails.</td></tr>
</table>
</dl><dl compact><dt><b>
Note: </b><dd>
The result is truncated to 31 bits, and may contain an incorrect sign bit on some older clients. New clients should use trafficGetMsgsSent8. </dl><dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classSmartSockets_1_1TipcSrv.html#a19">trafficGetMsgsSent8</a>. </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a61">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a19" doxytag="SmartSockets::TipcSrv::trafficGetMsgsSent8"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int8 SmartSockets::TipcSrv::trafficGetMsgsSent8 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the total number of messages written to the write buffer on a connection. This number usually is the same as the total number of messages actually sent on the connection, but sometimes the retrieved number is larger than the number of messages sent when the write buffer is not frequently flushed.
<p>
<dl compact><dt><b>
Returns: </b><dd>
the total number of messages written to the write buffer on a connection. </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the operation fails. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a62">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a53" doxytag="SmartSockets::TipcSrv::traverseSubscribe"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::traverseSubscribe </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSmartSockets_1_1TipcSrvSubjTraverser.html">TipcSrvSubjTraverser</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>travObj</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Traverses the list of subjects that connection is subscribing. This method invokes the <a class="el" href="classSmartSockets_1_1TipcSrvSubjTraverser.html#a4">TipcSrvSubjTraverser::onTraverse</a>() method for each entry in the subscription table, until either <a class="el" href="classSmartSockets_1_1TipcSrvSubjTraverser.html#a4">TipcSrvSubjTraverser::onTraverse</a>() returns false, or the table ends. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>travObj</em>&nbsp;</td><td>
- the traversal object to traverse through subjects </td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following code traverses through all the subjects that this object has subscribed and prints each one to the screen: <div class="fragment"><pre>
       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;
         /bar1
         /foo
       </pre></div> <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;

 <font class="keyword">class </font>MyTrav: <font class="keyword">public</font> TipcSrvSubjTraverser
 {
   <font class="keyword">public</font>:
     MyTrav()
     {
       cout &lt;&lt; <font class="stringliteral">"Subscribing to the following subjects:"</font> &lt;&lt; endl;
     }
     <font class="keyword">virtual</font> <font class="keywordtype">bool</font> onTraverse ( <font class="keyword">const</font> <font class="keywordtype">char</font>* subjectName)
     {
       cout &lt;&lt; <font class="stringliteral">"  "</font> &lt;&lt; subjectName &lt;&lt; endl;
       <font class="keywordflow">return</font> <font class="keyword">true</font>;
     }
 };
 <font class="keywordtype">int</font> main()
 {
   <font class="keywordflow">try</font>
   {
     MyTrav* trav = <font class="keyword">new</font> MyTrav();
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/foo"</font>,0);
     srv.setSubscribe(<font class="stringliteral">"/bar1"</font>);
     srv.traverseSubscribe(trav);
     <font class="keyword">delete</font> trav;
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> </dl>    </td>
  </tr>
</table>
<a name="a49" doxytag="SmartSockets::TipcSrv::unlock"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void SmartSockets::TipcSrv::unlock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Releases exclusive access to the connection. This method unlocks all of the internal synchronization objects within the connection to RTserver. <dl compact><dt><b>
Warning: </b><dd>
Every call to <a class="el" href="classSmartSockets_1_1TipcSrv.html#a48">lock</a>() must be balanced by a call to <a class="el" href="classSmartSockets_1_1TipcSrv.html#a49">unlock</a>(). </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if the lock cannot be acquired. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<a name="a39" doxytag="SmartSockets::TipcSrv::write"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SmartSockets::TipcSrv::write </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>check_server_msg_send</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a message and sends it through the connection. This is a convenience method that takes a null-terminated variable number of field type-value pairs. The field type part of the pair is T_IPC_FT, and the value part of the pair corresponds to the arguments for the related <a class="el" href="classSmartSockets_1_1TipcMsg.html#a102">TipcMsg::append</a>() methods (e.g. if the type is T_IPC_FT_REAL8, then the value part is a * REAL8 number) or TipcMsg::set* methods (if the type part is T_IPC_PROP_DELIVERY_MODE, then the value part is a T_IPC_DELIVERY_MODE setting). Some field types, such as arrays, use two arguments for the value part. Write() performs the following steps:<ul>
<li>Create a message of type mt<li>Append the fields to the message<li>Set the message sender to the value of the option Unique_Subject<li>Set the message destination to dest<li>Send the message with TipcSrvMsgSend<li>Destroy the message with TipcMsgDestroy Write() is a short wrapper function that calls TipcSrvMsgWriteVa. If check_server_msg_send is true and the option Server_Msg_Send is false, then TipcSrvMsgWrite does not send the message, but returns immediately. For normal usage, check_server_msg_send should always be true. This allows the user to globally turn off all normal outgoing messages by setting the option Server_Msg_Send to false. This is useful for running two RTclients, the primary one with Server_Msg_Send set to true and the backup one with Server_Msg_Send set to false.</ul>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
- destination, where the messages to be sent </td></tr>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
- the message type corresponding to the message </td></tr>
<tr><td valign=top><em>check_server_msg_send</em>&nbsp;</td><td>
- flag to determine whether or not the message is really sent. </td></tr>
<tr><td valign=top><em>var_arg_list</em>&nbsp;</td><td>
- the va_list parameters. The field type part of the pair is a T_IPC_FT and the value part of the pair corresponds to one of these arguments:<ul>
<li>The argument for the related TipcMsgAppend* function. For example, if the type part is T_IPC_FT_REAL8, then the value part is a REAL8 number.<li>The argument for the related TipcMsgSet* function. For example, if the type part is T_IPC_PROP_DELIVERY_MODE, then the value part is a T_IPC_DELIVERY_MODE setting. </ul>
</td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if an error occurs. </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following shows a short example that builds and sends a numeric data message to the subject "/primary/control": <div class="fragment"><pre>  ...
 <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv (<font class="stringliteral">"/foo"</font>, <font class="stringliteral">"tcp:_node"</font>);
 TipcMt mt (T_MT_NUMERIC_DATA);
 srv.write(<font class="stringliteral">"primary/control"</font>, mt, <font class="keyword">true</font>,
           T_IPC_FT_STR, <font class="stringliteral">"voltage1"</font>,
           T_IPC_FT_REAL8, 65.0,
           T_IPC_FT_STR, <font class="stringliteral">"current1"</font>,
           T_IPC_FT_REAL8, 10.335,
           NULL);
</pre></div> </dl>    </td>
  </tr>
</table>
<a name="a87" doxytag="SmartSockets::TipcSrv::writeCbCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classSmartSockets_1_1CallBack.html">CallBack</a>&lt;<a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a>&gt;* SmartSockets::TipcSrv::writeCbCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSmartSockets_1_1TipcMt.html">TipcMt</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSmartSockets_1_1MessageCallBack.html">MessageCallBack</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>implementor</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>arg</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw (<a class="el" href="classSmartSockets_1_1TipcException.html">TipcException</a>)<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a write callback. Write callback objects are called when a message is buffered to be sent through a connection's socket, which occurs when <a class="el" href="classSmartSockets_1_1TipcSrv.html#a37">send</a>() is called. Connection write callbacks are useful for message file logging and processing of messages before they are actually sent.
<p>
A write callback is usually created for a specific message type and connection. If the message type is null, then a global write callback is created for all message types on that connection.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>mt</em>&nbsp;</td><td>
the message type for the callback </td></tr>
<tr><td valign=top><em>implementor</em>&nbsp;</td><td>
a messagen callback implementation </td></tr>
<tr><td valign=top><em>arg</em>&nbsp;</td><td>
argument data for the callback </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
the constructed callback object </dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classSmartSockets_1_1TipcSrvException.html">TipcSrvException</a></em>&nbsp;</td><td>
 if creation of the callback fails </td></tr>
</table>
</dl><dl compact><dt><b>
Example:</b><dd>
 The following example shows a write callback that gets triggered for all outgoing messages: <div class="fragment"><pre><font class="preprocessor"> #include &lt;rtworks/sscpp.h&gt;</font>
<font class="preprocessor"> #include &lt;iostream&gt;</font>
 <font class="keyword">using</font> <font class="keyword">namespace </font>SmartSockets;
 <font class="keyword">using</font> <font class="keyword">namespace </font>std;

 <font class="keyword">class </font>MyCb : <font class="keyword">public</font> MessageCallBack
 {
   <font class="keyword">public</font>:
     <font class="keywordtype">void</font> onMessage (CallBack &lt;MessageCallBack&gt; * cb,
                      TipcMsg &amp; message,
                      TipcConn &amp; connection)
     {
       cout &lt;&lt; <font class="stringliteral">"in onMessage(); - (write Cb) "</font>
            &lt;&lt; message.getType().getName() &lt;&lt; endl;
     }
 };
 <font class="keywordtype">int</font> main ()
 {
   <font class="keywordflow">try</font>
   {
     <a class="code" href="classSmartSockets_1_1TipcSrv.html#a0">TipcSrv</a> srv(<font class="stringliteral">"/foo"</font>,<font class="stringliteral">"tcp:_node"</font>);
     MyCb* myCb = <font class="keyword">new</font> MyCb();
     srv.open();
     TipcMt mt((T_IPC_MT)NULL);
     CallBack&lt;MessageCallBack&gt;* cb = srv.writeCbCreate(mt, myCb);

     TipcMsg msg(T_MT_INFO,<font class="stringliteral">"/foo"</font>);
     msg &lt;&lt; <font class="stringliteral">"test"</font>;
     srv.send(msg);
     srv.mainLoop(10.0);
     <font class="comment">// This should disable the callback.</font>
     cb-&gt;destroy();

     <font class="keyword">delete</font> myCb;
   }
   <font class="keywordflow">catch</font> (...)
   {
   }
   <font class="keywordflow">return</font> 0;
 }
</pre></div> Here's the output of this code: <div class="fragment"><pre>
       TAL-SS-00088-I Connecting to project &lt;rtworks&gt; on &lt;tcp:_node&gt; RTserver
       TAL-SS-00089-I Using tcp protocol
       TAL-SS-00091-I Message from RTserver: Connection established.
       TAL-SS-00096-I Start subscribing to subject &lt;/foo&gt;
       in onMessage(); - (write Cb) info

       </pre></div> </dl>
<p>
Reimplemented from <a class="el" href="classSmartSockets_1_1TipcConn.html#a36">SmartSockets::TipcConn</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="tsrv_8h-source.html">tsrv.h</a></ul>
<hr><address><small>Generated on Mon Apr 13 16:28:27 2009 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.12 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
